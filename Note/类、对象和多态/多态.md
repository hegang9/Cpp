### 多态概念
多态指的是“同一种接口，不同的行为”

### 多态分类
1. 编译时多态（静态多态）：函数重载、运算符重载
2. 运行时多态（动态多态）：虚函数＋继承

##### 编译时多态可以代替运行时多态吗？
不完全可以，如果对象的真实类型在编译时即可确定，且想避免虚函数开销，就可以使用模板＋策略模式模拟运行时多态。代码示例如下：
```
    // 定义不同的策略类 - 它们无需继承自同一个基类
struct FastStrategy {
    void execute() const {
        // 高速算法的实现...
    }
};

struct RobustStrategy {
    void execute() const {
        // 稳健算法的实现...
    }
};

// 使用模板的策略上下文类
template <typename Strategy> // Strategy 是模板参数
class Processor {
private:
    Strategy strategy; // 在编译时持有具体策略
public:
    void run() {
        // 直接调用策略方法，编译器知道具体的Strategy类型
        strategy.execute(); // 此调用可以被内联！
    }
};

// 使用方式：在编译时选择策略
Processor<FastStrategy> fastProcessor;  // 编译器为FastStrategy生成特化代码
fastProcessor.run(); // 调用FastStrategy::execute

Processor<RobustStrategy> robustProcessor; // 编译器为RobustStrategy生成另一份代码  
robustProcessor.run(); // 调用RobustStrategy::execute
```

### 虚函数底层机制
通过虚函数表（vtable）和虚函数表指针（vptr）在运行时动态查找并调用正确的函数
- 虚函数表(vtable)：编译器在**编译阶段**为每个包含虚函数的类生成的**静态函数指针数组**（每个包含虚函数的类都有一个），这个数组按顺序存放了该类所有虚函数的地址（用指针表示），虚函数表存在于**只读数据段**，被该类的所有对象共享；
- 虚函数表指针(vptr)：当创建一个包含虚函数的类的对象时，编译器会在该对象的内存布局的**起始位置**（通常是开头）插入一个隐藏的指针成员，这就是vptr。它在对象构造时被自动**初始化为指向其所属类的虚函数表**

#### 继承下的虚函数表
派生类会拷贝一份基类的虚函数表作为自己的初始虚函数表，**重写基类虚函数会在该虚函数表中替换对应函数指针；新增虚函数会将该虚函数的地址追加到虚函数表末尾**。如果该派生类具有多个基类，那么会拷贝多个虚函数表（相互独立），并且对应的也会有多个虚表指针，第一个基类被视为“主基类”，派生类新增的虚函数的地址追加到主基类对应的虚函数表中，替换操作不变
##### 特殊情况，菱形继承的虚基类表和虚基类表指针
- 菱形继承的问题：根基类会被多次构造，浪费存储空间，且会造成二义性（最终派生类中会有多个根基类的成员变量，它们可以使用“最终派生类对象.中间类名::”来区别，这两个变量互相隔离）。
  
- 解决方法：中间类使用虚继承，虚继承可保证在最终派生类中只有一个根基类的成员变量，虽然它可以以“最终派生类对象.中间类名::”的形式进行访问，但是此时c.B1::param与c.B2::param是同一个变量，即最终派生类只继承一次根基类。
- 虚基类表(vbtable)：在菱形虚继承中，虚基类表不是一个函数地址表，而是一个偏移量表，它的第一个条目通常存储vbptr到当前子对象起始地址的偏移（通常为0），第二个条目则存储从当前vbptr到共享虚基类子对象的偏移量。当需要通过一个中间类指针访问共享基类的成员时，无论这个指针指向的是单纯的中间类对象还是最终派生类，过程都是一样的：通过vbptr找到vbtable，取出第二个条目中的偏移量，然后将当前this指针（指向中间类）加上这个偏移量，找到共享基类子对象的正确地址，然后进行访问。这种机制确保无论在哪个中间类访问共享基类，找到的都是同一份共享基类实例。
- 虚基类表指针(vbptr)：对象中用于指定虚基类表位置的指针
- 创建时机：虚基类表在编译时创建，编译器在编译时发现虚继承，创建虚基类表，该表记录虚基类子对象相对于当前类对象的固定偏移量。虚基类表存储在只读数据段。虚基类表指针vbptr的初始化工作由当前被构造的最具体、最底层的派生类（称为“最派生类”）的构造函数负责完成。在构造一个Final类对象时，Final的构造函数会确保其内部B部分和C部分的vbptr都正确指向各自的虚基类表，从而保证能通过正确的偏移量找到共享的虚基类A的子对象。
- **一个类是否拥有自己的虚基类表，取决于它是否直接以虚继承的方式继承自某个基类**，根本虚基类没有虚基类表。

#### 虚基类表和虚函数表的区别
虚函数表解决如何调用的问题，虚基类表解决对象在哪里的问题。


### 虚函数和纯虚函数的区别
1. 虚函数能被实现，当派生类没有重写，将使用基类的实现；
2. 虚函数的类可以被实例化

### 虚析构函数的作用
确保在通过基类指针删除派生类对象时，能够正确调用派生类的析构函数，从而释放对象所占用的资源。

### 哪些函数不能被声明为虚函数
1. 构造函数
2. 普通函数
3. 静态成员函数——静态成员函数对于每个类来说只有一份代码，没有动态绑定的必要性
4. 友元函数
5. 内联成员函数——在编译期被展开，但是虚函数需要在运行期动态绑定，两者矛盾

### 构造函数不能够声明为虚函数的原因
首先是顺序冲突：虚函数表指针依赖类对象，构造函数调用时对象还没创建，如果构造函数是虚函数，那么调用它就应该使用虚函数表指针来查找虚函数表，可是此时虚函数表指针还没创建，这就产生了矛盾，会导致编译期报错。
其次是多态目的：多态用于在运行时根据对象的实际类型调整行为，而对象构建时其类型一定是确定的，因此将构造函数声明为虚函数没有意义。

### 析构函数要设置为虚函数的原因
确保当通过基类指针删除派生类对象时，能够正确调用整个析构链，避免资源泄漏。