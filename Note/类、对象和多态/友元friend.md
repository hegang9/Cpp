# 40.友元friend介绍

友元是指：

采用类的机制后实现了数据的隐藏与封装，类的数据成员一般定义为私有成员，成员函数一般定义为公有的，依此提供类与外界间的通信接口。但是，有时需要定义一些函数，这些函数不是类的一部分（注意友元函数不是类的一部分），但又需要频繁地访问类的数据成员，这时可以将这些函数定义为该函数的友元函数。除了友元函数外，还有友元类，两者统称为友元。友元的作用是提高了程序的运行效率（即减少了类型检查和安全性检查等都需要时间开销），但它破坏了类的封装性和隐藏性，使得非成员函数可以访问类的私有成员。

 

```
class`  `Data{
``public` `:
``...``friend ` `int` `set` `(` `int` `&m);` `//友元函数friend class peop;   //友元类``...
``}
```

 

友元分为友元函数和友元类，两种具有不同的调用形式：

A友元函数：



友元函数是可以直接访问类的私有成员的非成员函数。它是定义在类外的普通函数，它不属于任何类，但需要在类的定义中加以

声明，声明时只需在友元的名称前加上关键字friend，其格式如下：
   

friend 类型 函数名(形式参数);

1.友元函数的声明可以放在类的私有部分，也可以放在公有部分，它们是没有区别的，都说明是该类的一个友元函数。


2.一个函数可以是多个类的友元函数，只需要在各个类中分别声明。友元函数的调用与一般函数的调用方式和原理一致。

 

B友元类

友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。当希望一个

类可以存取另一个类的私有成员时，可以将该类声明为另一类的友元类。


   例如，以下语句说明类B是类A的友元类：

```
class A{
 …
public:
 friend class B;
…
};
```

 

 经过以上说明后，类B的所有成员函数都是类A的友元函数，能存取类A的私有成员和保护成员。

   使用友元类时注意：

 

(1) 友元关系不能被继承。

 

(2) 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。

 

(3) 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明 

 

(4) 友元函数并不是类的成员函数，因此在类外定义的时候不能加上class::function name

 

下面我们完整的看一个友元的例子：


```
 1    #include 
 2 　　#include 
 3      class Point//声明
 4 　　{
 5 　　public:
 6 　　　　Point(double xx, double yy) { x=xx; y=yy; }//默认构造函数
 7 　　　　void Getxy();//公有成员函数
 8 　　　　friend double Distance(Point &a, Point &b);//友元函数
 9 　　private:
10 　　　　double x, y;
11 　　};
12 
13 　　void Point::Getxy()
14 　　{
15 　　cout<<"("<
16 　　}
17 
18 　　double Distance(Point &a, Point &b)  //注意函数名前未加类声明符
19 　　{
20 　　double dx = a.x - b.x;
21 　　double dy = a.y - b.y;
22 　　return sqrt(dx*dx+dy*dy);
23 　　}
24 
25 　　void main()
26 　　{
27 　　Point p1(3.0, 4.0), p2(6.0, 8.0);
28 　　p1.Getxy();
29 　　p2.Getxy();
30 　　double d = Distance(p1, p2);
31 　　cout<<"Distance is"<
32 　　} 
```