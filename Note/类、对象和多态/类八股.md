### 委托构造函数
C++11 引入的委托构造函数（Delegating Constructor）是一个旨在提升代码可维护性和减少冗余的强大特性。它允许同一个类中的一个构造函数在其初始化列表中调用另一个构造函数：
```
class MyClass {
public:
    // 目标构造函数 (通常是最具完整性的构造函数)
    MyClass(int a, int b) : x(a), y(b) {
        // 主初始化逻辑
    }

    // 委托构造函数 - 委托给 MyClass(int, int)
    MyClass() : MyClass(0, 0) { // 使用默认参数
    }

    // 另一个委托构造函数
    MyClass(int a) : MyClass(a, 0) { // 补全缺失参数
    }

private:
    int x, y;
};
```

### 如何定义只能在堆上生成对象的类？
- 方法1：私有构造函数 + 禁用拷贝和移动构造 + 使用create方法。这种方法在代码中体现为create函数搭配delete使用，违反设计直觉，不是特别好
```c++
class HeapOnly{
private:
    HeapOnly()=default; // 构造私有化

public:
    ~HeapOnly()=default;
    static HeapOnly* create(){  // 注意一定要设置为static
        return new HeapOnly();
    }

    HeapOnly(const HeapOnly&)=delete;
    HeapOnly& operator=(const HeapOnly&)=delete;
    HeapOnly(HeapOnly&&)=delete;
};
```

- 方法2：私有析构函数 + 禁用拷贝和移动构造 + 使用destroy方法。同方法1一样，违反设计直觉
- 方法3：同时私有构造和析构 + 使用create和destroy + 禁止拷贝和移动构造
```c++
class HeapOnly{
private:
    HeapOnly()=default; // 构造私有化
    ~HeapOnly()=default;

public:
    
    static HeapOnly* create(){  // 注意一定要设置为static
        return new HeapOnly();
    }

    void destroy(){
        delete this;
    }

    HeapOnly(const HeapOnly&)=delete;
    HeapOnly& operator=(const HeapOnly&)=delete;
    HeapOnly(HeapOnly&&)=delete;
};

```
- 方法3改造：目前方法3虽然能够实现只能在堆上创建类对象，但是其使用create和destroy，破坏了RAII设计原则，不利于内存管理，可使用智能指针来对create进行改造，并将destroy作为自定义删除器：
```c++
class HeapOnly{
private:
    HeapOnly()=default; // 构造私有化
    ~HeapOnly()=default;

public:
    
    static std::unique_ptr<HeapOnly,void(*)(HeapOnly*)> create(){  // 注意一定要设置为static
        return std::unique_ptr<HeapOnly,void(*)(HeapOnly*)>(new HeapOnly(),[](HeapOnly* p){
            p->destroy();
        });
    }

    void destroy(){
        delete this;
    }

    HeapOnly(const HeapOnly&)=delete;
    HeapOnly& operator=(const HeapOnly&)=delete;
    HeapOnly(HeapOnly&&)=delete;
};

```

### 如何定义只能在栈上生成对象的类？
- 方法1：禁用new和placement new：
```c++
class StackOnly{
public:
    StackOnly()=default;
    ~StackOnly()=default;
    void* operator new(size_t)=delete;
    void* operator new[](size_t)=delete;
    void* operator new(size_t,void* p)=delete;
};
```
