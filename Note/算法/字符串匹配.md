# 字符串匹配算法详解（C++）

## 1. 问题定义

给定：

- 文本串 `text`，长度为 $n$
- 模式串 `pattern`，长度为 $m$

目标：在 `text` 中找到 `pattern` 的所有出现位置（或第一个出现位置）。

常见变体：

- **单模式匹配**：一个模式串在一个文本中匹配。
- **多模式匹配**：多个模式串在同一文本中匹配。
- **精确匹配**：字符必须完全一致。
- **近似匹配**：允许一定编辑距离（本文不展开）。

---

## 2. 暴力匹配（Brute Force）

### 2.1 核心思想

从 `text` 的每个可能起点 `i` 开始，逐字符比较 `text[i + j]` 和 `pattern[j]`。

### 2.2 C++ 示例

```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> bruteForceMatch(const string& text, const string& pattern) {
	vector<int> positions;
	int n = static_cast<int>(text.size());
	int m = static_cast<int>(pattern.size());

	if (m == 0) {
		for (int i = 0; i <= n; ++i) positions.push_back(i);
		return positions;
	}

	for (int i = 0; i + m <= n; ++i) {
		int j = 0;
		while (j < m && text[i + j] == pattern[j]) ++j;
		if (j == m) positions.push_back(i);
	}
	return positions;
}
```

### 2.3 复杂度

- **时间复杂度**：最坏 $O((n-m+1)\cdot m) \approx O(nm)$
- **空间复杂度**：$O(1)$（不计输出）

### 2.4 适用场景

- 模式串很短，且数据规模小。
- 对性能要求不高，强调实现简单。
- 作为其他算法正确性的对照基线。

---

## 3. KMP 算法

### 3.1 核心思想

当匹配失败时，不回退文本指针，而是利用模式串自身结构（前后缀信息）跳转。

关键数组：`lps`（Longest Prefix Suffix）

- `lps[i]` 表示 `pattern[0..i]` 的最长相等真前后缀长度。

### 3.2 C++ 示例

```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> buildLPS(const string& pattern) {
	int m = static_cast<int>(pattern.size());
	vector<int> lps(m, 0);
	for (int i = 1, len = 0; i < m; ) {
		if (pattern[i] == pattern[len]) {
			lps[i++] = ++len;
		} else if (len > 0) {
			len = lps[len - 1];
		} else {
			lps[i++] = 0;
		}
	}
	return lps;
}

vector<int> kmpMatch(const string& text, const string& pattern) {
	vector<int> positions;
	int n = static_cast<int>(text.size());
	int m = static_cast<int>(pattern.size());
	if (m == 0) {
		for (int i = 0; i <= n; ++i) positions.push_back(i);
		return positions;
	}

	vector<int> lps = buildLPS(pattern);
	for (int i = 0, j = 0; i < n; ) {
		if (text[i] == pattern[j]) {
			++i;
			++j;
			if (j == m) {
				positions.push_back(i - m);
				j = lps[j - 1];
			}
		} else if (j > 0) {
			j = lps[j - 1];
		} else {
			++i;
		}
	}
	return positions;
}
```

### 3.3 复杂度

- **预处理**：$O(m)$
- **匹配过程**：$O(n)$
- **总时间复杂度**：$O(n+m)$
- **空间复杂度**：$O(m)$

### 3.4 适用场景

- 单模式匹配，且需要稳定线性时间上界。
- 文本很长，模式固定，要求最坏情况性能可控。
- 不适合极端追求常数因子的短串场景（实现复杂度稍高）。

---

## 4. Rabin-Karp（哈希匹配）

### 4.1 核心思想

用滚动哈希比较窗口子串与模式串：

1. 若哈希不同，直接判不匹配。
2. 若哈希相同，再做一次逐字符校验（防哈希冲突）。

### 4.2 C++ 示例（单哈希版）

```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> rabinKarpMatch(const string& text, const string& pattern) {
	vector<int> positions;
	int n = static_cast<int>(text.size());
	int m = static_cast<int>(pattern.size());
	if (m == 0) {
		for (int i = 0; i <= n; ++i) positions.push_back(i);
		return positions;
	}
	if (m > n) return positions;

	const long long base = 131;
	const long long mod = 1'000'000'007;

	long long patternHash = 0;
	long long windowHash = 0;
	long long power = 1;

	for (int i = 0; i < m; ++i) {
		patternHash = (patternHash * base + pattern[i]) % mod;
		windowHash = (windowHash * base + text[i]) % mod;
		if (i + 1 < m) power = (power * base) % mod;
	}

	auto equalAt = [&](int start) {
		for (int j = 0; j < m; ++j) {
			if (text[start + j] != pattern[j]) return false;
		}
		return true;
	};

	for (int i = 0; i + m <= n; ++i) {
		if (windowHash == patternHash && equalAt(i)) {
			positions.push_back(i);
		}
		if (i + m < n) {
			windowHash = (windowHash - text[i] * power % mod + mod) % mod;
			windowHash = (windowHash * base + text[i + m]) % mod;
		}
	}

	return positions;
}
```

### 4.3 复杂度

- **平均时间复杂度**：$O(n+m)$
- **最坏时间复杂度**：$O(nm)$（大量哈希冲突）
- **空间复杂度**：$O(1)$（不计输出）

### 4.4 适用场景

- 需要快速筛选候选匹配位置。
- 多模式长度相同的批量匹配（可扩展）。
- 对极端最坏情况不敏感时。

工程上常使用**双哈希**降低冲突概率。

---

## 5. Sunday 算法

### 5.1 核心思想

比较窗口失败后，查看窗口后一个字符 `text[i + m]`：

- 若该字符在 `pattern` 中出现，则按“最右出现位置”移动。
- 若未出现，则直接跳过 `m + 1`。

### 5.2 C++ 示例

```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> sundayMatch(const string& text, const string& pattern) {
	vector<int> positions;
	int n = static_cast<int>(text.size());
	int m = static_cast<int>(pattern.size());

	if (m == 0) {
		for (int i = 0; i <= n; ++i) positions.push_back(i);
		return positions;
	}

	vector<int> shift(256, m + 1);
	for (int i = 0; i < m; ++i) {
		shift[static_cast<unsigned char>(pattern[i])] = m - i;
	}

	int i = 0;
	while (i + m <= n) {
		int j = 0;
		while (j < m && text[i + j] == pattern[j]) ++j;
		if (j == m) positions.push_back(i);

		if (i + m >= n) break;
		i += shift[static_cast<unsigned char>(text[i + m])];
	}

	return positions;
}
```

### 5.3 复杂度

- **平均时间复杂度**：通常优于暴力，接近 $O(n)$（与数据分布相关）
- **最坏时间复杂度**：$O(nm)$
- **空间复杂度**：$O(|\Sigma|)$，ASCII 下可视为常数

### 5.4 适用场景

- 实际工程中的普通文本搜索。
- 字符集稳定（如 ASCII/UTF-8 字节级处理）时实现高效。
- 追求实现简洁且平均性能较好。

---

## 6. Boyer-Moore（BM）

### 6.1 核心思想

从模式串末尾开始比较，失配后应用两类规则：

- **坏字符规则**（bad character）
- **好后缀规则**（good suffix）

每次可能跳过较大距离，实际表现常很好。

### 6.2 复杂度

- **预处理**：$O(m + |\Sigma|)$（视实现而定）
- **平均时间复杂度**：通常很优（常接近 $O(n/m)$ 级别的跳跃效果）
- **最坏时间复杂度**：经典 BM 可到 $O(nm)$，改进版本可做到线性上界
- **空间复杂度**：$O(m + |\Sigma|)$

### 6.3 适用场景

- 长模式串、长文本、字符集较大时非常常用。
- 工业实现（如标准库/搜索工具）中常见变体。

> 注：BM 的完整实现细节较多，工程中常直接使用成熟库。

---

## 7. Aho-Corasick（AC 自动机，多模式）

### 7.1 核心思想

将多个模式串构建为 Trie，并加入失败指针（类似 KMP 的思想扩展），实现单次扫描文本完成多模式匹配。

### 7.2 复杂度

- **构建自动机**：$O(\sum |P_i| \cdot \alpha)$（与实现和字符集有关）
- **匹配**：$O(n + \text{occ})$，`occ` 为匹配输出总数
- **空间复杂度**：与 Trie 节点数和字符集相关

### 7.3 适用场景

- 敏感词过滤
- 日志关键词批量检索
- 词典匹配、DNA 多模式搜索

---

## 8. 算法横向对比

| 算法 | 预处理 | 匹配时间（平均） | 最坏时间 | 额外空间 | 典型场景 |
| --- | --- | --- | --- | --- | --- |
| 暴力 | 无 | 一般 | $O(nm)$ | $O(1)$ | 小数据、教学、基线 |
| KMP | $O(m)$ | $O(n)$ | $O(n)$ | $O(m)$ | 单模式、要求稳定上界 |
| Rabin-Karp | $O(m)$ | $O(n)$ | $O(nm)$ | $O(1)$ | 哈希筛选、批量同长模式 |
| Sunday | $O(m+|\Sigma|)$ | 通常较快 | $O(nm)$ | $O(|\Sigma|)$ | 工程文本搜索 |
| Boyer-Moore | $O(m+|\Sigma|)$ | 常很快 | 依实现 | $O(m+|\Sigma|)$ | 长串高性能搜索 |
| AC 自动机 | $O(\sum |P_i|)$ 级 | $O(n+occ)$ | $O(n+occ)$ | 较高 | 多模式匹配 |

---

## 9. 选型建议（工程视角）

- **只匹配一个模式，且要严格最坏线性上界**：优先 `KMP`。
- **普通文本检索，追求易实现和高平均性能**：可选 `Sunday`。
- **长模式+大文本，追求跳跃式高性能**：考虑 `Boyer-Moore` 或其变体。
- **多个模式同时匹配**：首选 `AC 自动机`。
- **可接受小概率冲突，想利用哈希加速**：`Rabin-Karp`（建议双哈希）。

---

## 10. 统一测试示例（C++）

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	string text = "ababcabcabababd";
	string pattern = "ababd";

	// 你可以将这里替换为 bruteForceMatch / kmpMatch / sundayMatch / rabinKarpMatch
	// 以 kmpMatch 为例：
	auto positions = [&]() {
		vector<int> res;
		int n = static_cast<int>(text.size());
		int m = static_cast<int>(pattern.size());
		vector<int> lps(m, 0);
		for (int i = 1, len = 0; i < m; ) {
			if (pattern[i] == pattern[len]) lps[i++] = ++len;
			else if (len > 0) len = lps[len - 1];
			else lps[i++] = 0;
		}
		for (int i = 0, j = 0; i < n; ) {
			if (text[i] == pattern[j]) {
				++i; ++j;
				if (j == m) { res.push_back(i - m); j = lps[j - 1]; }
			} else if (j > 0) {
				j = lps[j - 1];
			} else {
				++i;
			}
		}
		return res;
	}();

	cout << "Match positions: ";
	for (int pos : positions) cout << pos << ' ';
	cout << '\n';
	return 0;
}
```

---

## 11. 常见面试问法速记

- `KMP` 为什么是线性时间？
  - 因为文本指针不回退，模式指针的回退总次数受限于 $m$。
- `Rabin-Karp` 为什么要二次校验？
  - 哈希可能冲突，哈希相等不代表字符串一定相等。
- `BM/Sunday` 为什么实际常比 KMP 快？
  - 失配后常能跨多字符跳跃，减少比较次数。
- 何时必须用 `AC`？
  - 当模式串数量多且文本扫描次数受限时。

---

## 12. 小结

字符串匹配没有“绝对最优”算法，关键在于：

- 模式数量（单模式 / 多模式）
- 文本与模式长度分布
- 是否要求最坏情况上界
- 是否接受概率正确性（哈希冲突）

工程实践中，常见策略是：

1. 先根据场景选算法（KMP / Sunday / BM / AC）。
2. 用真实业务数据压测。
3. 再做常数优化与边界处理。
# 字符串匹配算法（C++）

> 字符串匹配（String Matching）问题：给定**文本串** `text`（长度为 $n$）和**模式串** `pattern`（长度为 $m$），查找模式串在文本串中出现的位置（首次出现/全部出现）。

---

## 1. 问题定义与术语

- **精确匹配**：字符必须逐个完全相等。
- **单次匹配**：找到第一个匹配位置即可。
- **多次匹配**：找出所有匹配位置。
- **字母表大小**：字符集合规模（如 ASCII、UTF-8 字节流等）。

下文默认：

- $n = |text|$
- $m = |pattern|$
- 若无特别说明，假设 $m > 0$。

---

## 2. 朴素匹配（Brute Force / Naive）

### 2.1 思路

从 `text[0]` 开始，尝试让 `pattern` 与 `text[i...i+m-1]` 对齐，逐字符比较；失败就将起点 `i` 后移一位。

### 2.2 复杂度

- **最坏时间复杂度**：$O((n-m+1)\cdot m)$，约 $O(nm)$
- **最好时间复杂度**：$O(n)$（常常第一字符就失配）
- **空间复杂度**：$O(1)$

### 2.3 C++ 示例（返回首个匹配位置）

```cpp
#include <string>

int naiveSearch(const std::string& text, const std::string& pattern) {
	if (pattern.empty()) return 0;
	int n = static_cast<int>(text.size());
	int m = static_cast<int>(pattern.size());
	if (m > n) return -1;

	for (int i = 0; i <= n - m; ++i) {
		int j = 0;
		while (j < m && text[i + j] == pattern[j]) {
			++j;
		}
		if (j == m) return i;
	}
	return -1;
}
```

### 2.4 适用场景

- 模式串很短、数据规模小。
- 一次性脚本或面试手写快速实现。
- 对性能要求不高时。

---

## 3. KMP（Knuth-Morris-Pratt）

### 3.1 核心思想

朴素算法在失配后会回退文本指针，KMP 通过预处理 `pattern`，利用“已匹配前缀的信息”避免文本回退。

关键数组通常叫：

- `next`
- 或 `lps`（Longest Prefix Suffix，最长相等前后缀长度）

当 `pattern[j]` 与 `text[i]` 失配时，`j` 跳到 `lps[j-1]`，`i` 不回退。

### 3.2 复杂度

- 构建 `lps`：$O(m)$
- 匹配过程：$O(n)$
- **总时间复杂度**：$O(n+m)$
- **空间复杂度**：$O(m)$

### 3.3 C++ 示例（返回所有匹配位置）

```cpp
#include <vector>
#include <string>

std::vector<int> buildLPS(const std::string& pattern) {
	int m = static_cast<int>(pattern.size());
	std::vector<int> lps(m, 0);
	int len = 0;
	for (int i = 1; i < m; ++i) {
		while (len > 0 && pattern[i] != pattern[len]) {
			len = lps[len - 1];
		}
		if (pattern[i] == pattern[len]) {
			++len;
		}
		lps[i] = len;
	}
	return lps;
}

std::vector<int> kmpSearchAll(const std::string& text, const std::string& pattern) {
	std::vector<int> result;
	if (pattern.empty()) {
		result.push_back(0);
		return result;
	}

	int n = static_cast<int>(text.size());
	int m = static_cast<int>(pattern.size());
	if (m > n) return result;

	std::vector<int> lps = buildLPS(pattern);
	int j = 0;

	for (int i = 0; i < n; ++i) {
		while (j > 0 && text[i] != pattern[j]) {
			j = lps[j - 1];
		}
		if (text[i] == pattern[j]) {
			++j;
		}
		if (j == m) {
			result.push_back(i - m + 1);
			j = lps[j - 1];
		}
	}
	return result;
}
```

### 3.4 适用场景

- 需要严格最坏复杂度保证。
- 文本很大、模式固定、重复查询。
- 不能接受哈希碰撞风险（相比 Rabin-Karp）。

---

## 4. Rabin-Karp（RK，滚动哈希）

### 4.1 核心思想

比较子串时不直接逐字符比较，而是比较哈希值：

1. 计算 `pattern` 哈希值。
2. 计算 `text` 每个长度为 $m$ 窗口的哈希值（滚动更新）。
3. 哈希相同再做一次字符校验（防止碰撞）。

### 4.2 复杂度

- **平均时间复杂度**：$O(n+m)$（碰撞少）
- **最坏时间复杂度**：$O(nm)$（大量碰撞导致频繁二次校验）
- **空间复杂度**：$O(1)$（不计结果）

### 4.3 C++ 示例（单模匹配）

```cpp
#include <vector>
#include <string>

std::vector<int> rabinKarpSearchAll(const std::string& text, const std::string& pattern) {
	std::vector<int> result;
	int n = static_cast<int>(text.size());
	int m = static_cast<int>(pattern.size());
	if (m == 0) {
		result.push_back(0);
		return result;
	}
	if (m > n) return result;

	const long long base = 256;
	const long long mod = 1000000007LL;

	long long patHash = 0;
	long long winHash = 0;
	long long power = 1;

	for (int i = 0; i < m - 1; ++i) {
		power = (power * base) % mod;
	}

	for (int i = 0; i < m; ++i) {
		patHash = (patHash * base + static_cast<unsigned char>(pattern[i])) % mod;
		winHash = (winHash * base + static_cast<unsigned char>(text[i])) % mod;
	}

	for (int i = 0; i <= n - m; ++i) {
		if (patHash == winHash) {
			if (text.compare(i, m, pattern) == 0) {
				result.push_back(i);
			}
		}
		if (i < n - m) {
			winHash = (winHash - static_cast<unsigned char>(text[i]) * power) % mod;
			if (winHash < 0) winHash += mod;
			winHash = (winHash * base + static_cast<unsigned char>(text[i + m])) % mod;
		}
	}
	return result;
}
```

### 4.4 适用场景

- 大量“等长子串比较”场景。
- 多模式匹配（可扩展：将多个模式哈希入集合）。
- 对平均性能友好，且可接受极小概率碰撞风险。

---

## 5. Boyer-Moore（BM）与 Sunday

## 5.1 Boyer-Moore 核心思想

从模式串尾部开始比较，一旦失配，根据启发规则“跳过多个字符”：

- **坏字符规则（Bad Character）**
- **好后缀规则（Good Suffix）**

实践中常常表现非常快，尤其自然语言文本中。

### 5.2 Sunday 算法（BM 家族简化版）

Sunday 在失配后看“当前窗口后一个字符”来决定移动距离，实现更简洁，工程里很常用。

### 5.3 复杂度（概览）

- BM 预处理：$O(\Sigma + m)$ 或 $O(m)$（视实现）
- BM 匹配：平均较优，最坏可到 $O(nm)$（特定构造）
- Sunday 平均性能也很好，实现简单

### 5.4 C++ 示例（Sunday，返回首个匹配）

```cpp
#include <vector>
#include <string>

int sundaySearch(const std::string& text, const std::string& pattern) {
	int n = static_cast<int>(text.size());
	int m = static_cast<int>(pattern.size());
	if (m == 0) return 0;
	if (m > n) return -1;

	std::vector<int> shift(256, m + 1);
	for (int i = 0; i < m; ++i) {
		shift[static_cast<unsigned char>(pattern[i])] = m - i;
	}

	int i = 0;
	while (i <= n - m) {
		int j = 0;
		while (j < m && text[i + j] == pattern[j]) {
			++j;
		}
		if (j == m) return i;

		if (i + m >= n) return -1;
		i += shift[static_cast<unsigned char>(text[i + m])];
	}
	return -1;
}
```

### 5.5 适用场景

- 工程中追求“常数项性能”。
- 字母表较大、随机文本较多。
- 对最坏复杂度没有 KMP 那样强约束时。

---

## 6. 多模式匹配：Aho-Corasick（AC 自动机）

### 6.1 问题场景

当有很多模式串（如敏感词库）需要同时在文本中匹配时，逐个 KMP 会变慢。

AC 自动机把多个模式串构造成 Trie，并引入失败指针（类似 KMP 的回退思想），实现“一次扫描匹配多模式”。

### 6.2 复杂度

设总模式长度为 $L$，匹配结果数为 $z$：

- 构建自动机：$O(L \cdot \Sigma)$（朴素转移）或优化到近似 $O(L)$
- 匹配：$O(n + z)$

### 6.3 适用场景

- 敏感词过滤、词典匹配、入侵特征检测。
- 模式串数量大、需批量在线扫描。

---

## 7. 各算法对比总结

| 算法 | 单/多模式 | 平均时间 | 最坏时间 | 额外空间 | 特点 |
|---|---|---|---|---|---|
| 朴素匹配 | 单模式 | 较慢 | $O(nm)$ | $O(1)$ | 最简单、好写 |
| KMP | 单模式 | $O(n+m)$ | $O(n+m)$ | $O(m)$ | 最坏有保证 |
| Rabin-Karp | 单/可扩展多模式 | $O(n+m)$（均摊） | $O(nm)$ | $O(1)$ | 滚动哈希、易扩展 |
| BM/Sunday | 单模式 | 实践快 | 可能 $O(nm)$ | $O(\Sigma)$ | 常数项表现优秀 |
| AC 自动机 | 多模式 | $O(n+z)$ | $O(n+z)$ | 较高 | 多模式扫描利器 |

---

## 8. 如何选型（工程经验）

- **只查一次、规模小**：朴素即可。
- **单模式、要求稳定最坏性能**：优先 KMP。
- **单模式、追求实际速度**：尝试 Sunday/BM。
- **需要哈希能力（比如大量等长窗口）**：Rabin-Karp。
- **多模式词典扫描**：AC 自动机。

一个常见策略：

1. 先用 Sunday/BM 做基线（快、代码短）。
2. 对最坏情况敏感的核心路径换 KMP。
3. 多模式需求直接上 AC。

---

## 9. 常见坑点与注意事项

- **空模式串约定**：通常返回 `0`，但要与业务定义统一。
- **字符编码问题**：`std::string` 按字节处理 UTF-8，中文可能被拆成多个字节。
- **哈希碰撞**：RK 必须二次校验；可用双哈希降低风险。
- **越界处理**：窗口移动时注意 `i + m` 是否超界。
- **返回值设计**：区分“首个匹配位置 / 所有位置 / 是否存在”。

---

## 10. `std::string::find` 与手写算法

在业务代码中，如果只是普通查找，优先使用标准库：

```cpp
std::size_t pos = text.find(pattern);
if (pos != std::string::npos) {
	// found
}
```

手写算法主要用于：

- 学习算法思想与复杂度。
- 特定场景定制（多模式、流式处理、统计信息）。
- 面试或底层库开发。

---

## 11. 小结

- 字符串匹配核心在于“**失配后如何高效跳转**”。
- KMP 给出稳健的线性复杂度保证；BM/Sunday 常有更优实践速度；RK 在哈希场景灵活；AC 解决多模式匹配。
- 工程中优先考虑数据规模、最坏性能要求、模式数量与实现复杂度，再做算法选择。

