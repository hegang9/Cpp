# 迭代器失效

## 各容器失效规则
- vector：扩容会导致所有迭代器失效，删除或插入会导致位置之后的迭代器失效
- deque：与实现相关
- 链式存储结构（list、forward_list）：所有迭代器均有效，除被删除元素的迭代器外
- 关联式容器（set、map、unordered_set、unordered_map等）：所有迭代器均有效，除被删除元素的迭代器外；但 rehash 和 reserve 会导致 unordered 系列容器的所有迭代器失效

## 踩坑示例
- vector 边遍历边删除元素
- vector 未实现 reserve 导致扩容
- 哈希容器未实现 reserve 导致 rehash

## 如何避免迭代器失效
- 使用返回值继续遍历
  - erase（C++11 起）返回下一个有效迭代器：`it = c.erase(it);`
- 提前容量规划（连续存储容器）
  - vector/string 在大量插入前 `reserve(n)`，减少扩容次数
- 遍历时尽量不用下标 + 外部缓存迭代器
  - 修改容器后重新获取相关迭代器/指针/引用
- 选择“节点稳定”的容器
  - 频繁插删且需要稳定迭代器：优先 list、(unordered_)map/set
- 注意哈希容器的 rehash
  - 批量插入前 reserve；rehash 后全部迭代器作废
- 使用“索引遍历”替代“迭代器遍历”（当容器允许且你可控制索引失效）
  - 对 vector 的尾删可用索引；警惕插入/删除导致的元素移动
- 不要持有临时容器元素的引用/迭代器
  - 返回局部容器的迭代器/引用 → 悬垂
- 范围 for + 拷贝值
  - 如只读数据且容器会变更结构，考虑先拷贝必要的值到临时数组再处理
