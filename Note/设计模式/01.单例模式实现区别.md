# 01.单例模式实现区别

## 一、什么是单例模式

需要应用单例模式的对象通常只能有一个实例存在。比如我们每个人只能有一条生命，太阳系只有一个太阳，每个人只有一个身份证号。

单例模式的实现方式是，隐藏构造方法，在内部初始化一次，并提供一个全局的访问点。

通过单例模式，我们可以保证系统中只有一个实例，从而在某些特定的场合下达到节约或者控制系统资源的目的。如下是一些单例使用的场景：

- 需要频繁创建的一些类，使用单例能够降低系统内存使用率，减少GC；
- 某些类在创建实例时会消耗较多资源，或者耗时也比较长，且经常使用，那么使用单例能一直保持这个单例，提升系统资源的使用效率；
- 频繁访问数据库或者文件的IO对象；
- 对于一些硬件级别的实例或者逻辑上需要单例的场景；

单例模式有很多实现方式，我们来逐一看下都有哪些，以及它们之间有什么区别和优缺点。

### 1.1 饿汉模式的单例



```java
public class Wife1 {
    private static final Wife1 wife = new Wife1();
    // 将构造函数私有化，避免外部程序调用创建对象
    private Wife1(){}
    public static Wife1 getWife(){
        return wife;
    }
}
```

上面这种模式在一开始类被加载进行初始化的时候就创建了唯一的单例对象，因此这也是饿汉名字的来源。它的好处就是绝对的线程安全，在需要获取单例实例的时候执行效率较高，因为早就准备好了。比较适合在系统中单例个数不多的情况下，否则会造成内存浪费。

### 1.2 懒汉模式的单例



```java
public class Wife2 {
    private static Wife2 wife;
    private Wife2(){}
    public static Wife2 getWife(){
        if(wife == null){
            wife = new Wife2();
        }
        return wife;
    }
}
```

懒汉模式的示例对象只有在真正需要的时候才会被初始化，但由此也产生一个问题，它不是线程安全的，多线程情况下，可能会同时创建出多个实例对象。这是如何发生的呢？其实很简单：

我们假设有两个线程A和B同时调用`getWife`方法，A线程在判断完`if(wife == null)`之后为true，然后被阻塞了（阻塞方式有很多），此时轮到B线程判断`if(wife == null)`，结果也为true，那么它们两个同时认为当前没有人创建过实例，因此都会在接下来创建实例对象。

### 1.3 同步模式的单例



```java
public class Wife3 {
    private static Wife3 wife;
    private Wife3(){}
    public static synchronized Wife3 getWife(){
        if(wife == null){
            wife = new Wife3();
        }
        return wife;
    }
}
```

虽然我们在方法的调用上确保了同步，即同一时间只能有一个线程进入到方法的内部进行执行，但是这却带来了方法执行低效的问题，这是为什么呢？

如果说，实例对象却是从来没有被创建过，那么当前执行该方法的线程理所当然需要走`if(wife == null)`的逻辑，但是如果已经有实例对象被创建好了，每个线程每次调用都得走这个判断逻辑，而且还是同步的方式，效率当然低了。这就好比千军万马本来只需要走一个1米的独木桥（即例子中不需要判断`if(wife == null)`逻辑的情况）现在却不得不走2米的独木桥。

### 1.4 双重检查锁模式的单例



```java
public class Wife4 {
    private volatile static Wife4 wife;
    private Wife4(){}
    public static Wife4 getWife(){
        if(wife == null){
            synchronized(Wife4.class){
                if(wife == null){
                    wife = new Wife4();
                }
            }
        }
        return wife;
    }
}
```

这种模式就是上面所说的，走独木桥的方法被优化了，第一个走的人需要走2米，后面其他人都只要走1米了，这边有2个疑问：

1. 为什么在`synchronized`代码块中还要加上一个非空判断呢？

   答案和上面的同步模式的单例情况差不多。同样假设有两个线程A和B同时进入了`wife`为空的判断逻辑，它们只是在`synchronized`时进行资源的竞争，然后依然会全部执行完同步代码块中的创建对象的代码，只是谁先谁后执行的问题。所以，必须在创建对象前，再次进行判断，确认还未有人创建才可以继续创建。

2. 为什么此时的静态变量`wife`需要声明为`volatile`呢？

   确保wife变量的多线程场景下的可见性。具体可以参考[volatile使用详解 - 简书 (jianshu.com)](https://www.jianshu.com/p/28178eda6024)

### 1.5 静态内部类模式的单例



```java
public class Wife5 {
    private Wife5(){}
    private static class WifeHolder{
        private static final Wife5 wife = new Wife5();
    }
    public static Wife5 getWife(){
        return WifeHolder.wife;
    }
}
```

我们可以看到`WifeHolder` 类是私有的静态内部类，除了 `getWife()` 之外没有其它方式可以访问到`wife`实例对象，而且只有在调用`getWife`方法时，才会真正加载该静态内部类，获取到其中的静态常量，即`wife`对象，做到了懒加载。

至于线程安全方面，静态内部类则是利用了 JVM 自身的机制来保证线程安全，因为此处的内部类必须要在外部类的方法调用之前被初始化，所以当调用`getWife()`方法的时候，会先初始化内部类中的实例，这一点是线程安全的。

但是这样的写法看似简单、高效、完美，但是在使用反射的场景下就会出现问题：



```java
public static void main(String[] args){
      try{
           Class<?> clazz = Wife5.class;
           Constructor c = clazz.getDeclaredConstructor(null);
           // 强制将私有构造方法改为可访问的
           c.setAccessibel(ture);
           Object wife1 = c.newInstance();
           Object wife2 = c.newInstance();
      }catch(Exception e) {
           e.printStackTrace();
      }
}
```

如此，静态内部类的写法就会被反射所破坏，我们可以对私有构造方法做下改造，来防止这种情况。



```java
private Wife5(){
      if(WifeHolder.INSTANCE != null){
           throw new RuntimeException("不允许创建多个实例！");
      }
}
```

### 1.6 枚举模式的单例



```java
public enum EnumWifeSingleton {
    INSTANCE;

    private String name;
    public void setName(String name){
        this.name = name;
    }

    public String getName(){
        return this.name;
    }

    public static EnumWifeSingleton getWife(){
        return INSTANCE;
    }
}
```



```java
@Slf4j
public class Main {
    public static void main(String[] args) {
        EnumWifeSingleton marry = EnumWifeSingleton.getWife();
        marry.setName("marry");

        log.info("wife's name is :{}", marry.getName());
        EnumWifeSingleton lily = EnumWifeSingleton.getWife();
        log.info("marry is lily?:{}", marry == lily);
    }
}
```

这种方式区别于以上任何一种，它是利用枚举默认就是线程安全的特性来实现单例（类似与饿汉模式），此外，还可以防止反序列化带来的问题；使用反射也无法操作枚举类型。

但是缺点也是有的，枚举模式的单例虽然简洁优雅，但是和饿汉模式一样，都是提前创建好实例，只是适用单例较少的场景，不适合需要大规模生产单例的场景。

## 1.7 容器注册式的单例

在实际应用场景中，如果有大规模的单例需要创建，肯定需要有线考虑实现懒加载，那么就推荐使用容器注册式的单例：



```java
public class ContainerRegistrySingleton {
    /**
     * 私有化构造函数
     */
    private ContainerRegistrySingleton(){}

    /**
     * ioc容器，集中存放管理所有单例
     */
    private static Map<String,Object> ioc = new ConcurrentHashMap<String,Object>();

    public static Object getBean(String className){
        synchronized (ioc) {
            if(ioc.containsKey(className)){
                return ioc.get(className);
            }
            Object obj = null;
            try {
                obj = Class.forName(className).newInstance();
                ioc.put(className, obj);
            } catch (Exception e) {
                e.printStackTrace();
            }
            return obj;
        }
    }
}
```

其中的`ContainerRegistrySingleton`就相当于是Bean的单例容器，从它这里获取的各个Bean确保都是单例的，这种写法也正是Spring中的容器单例写法，详情可以参考`DefaultSingletonBeanRegistry`这个类的源码。

### 1.8 ThreadLocal实现线程单例

ThreadLocal的作用就是为每个线程保存一份自己独有的变量副本，详细使用方法可以参考[ThreadLocal的使用 - 简书 (jianshu.com)](https://www.jianshu.com/p/0d250a8814c2)



```java
public class ThreadLocalSingleton {
    /**
     * 私有化构造函数
     */
    private ThreadLocalSingleton() {}

    private static ThreadLocal<ThreadLocalSingleton> threadLocalInstance = new ThreadLocal<ThreadLocalSingleton>() {
        @Override
        protected ThreadLocalSingleton initialValue() {
            return new ThreadLocalSingleton();
        }
    };

    public static ThreadLocalSingleton getInstance(){
        return threadLocalInstance.get();
    }
}
```



```java
@Slf4j
public class CustomerThread implements Runnable{
    @Override
    public void run() {
        log.info("{}", ThreadLocalSingleton.getInstance());
    }
}

@Slf4j
public class Main {
    public static void main(String[] args) {
        // 主线程就一份该变量，即使调用三次，获取的都是同一个
        log.info("{}",ThreadLocalSingleton.getInstance());
        log.info("{}",ThreadLocalSingleton.getInstance());
        log.info("{}",ThreadLocalSingleton.getInstance());
        // 每个线程获取的是单例，线程之间获取的不是相同的对象实例
        Thread t1 = new Thread(new CustomerThread());
        Thread t2 = new Thread(new CustomerThread());
        t1.start();
        t2.start();
    }
}
```



```css
[main] INFO com.example.demo.create.singleton.Main - com.example.demo.create.singleton.ThreadLocalSingleton@754ba872
[main] INFO com.example.demo.create.singleton.Main - com.example.demo.create.singleton.ThreadLocalSingleton@754ba872
[main] INFO com.example.demo.create.singleton.Main - com.example.demo.create.singleton.ThreadLocalSingleton@754ba872
[Thread-0] INFO com.example.demo.create.singleton.CustomerThread - com.example.demo.create.singleton.ThreadLocalSingleton@85afa6e
[Thread-1] INFO com.example.demo.create.singleton.CustomerThread - com.example.demo.create.singleton.ThreadLocalSingleton@161afbac
```

使用ThreadLocal的如上方式，在线程内获取实例`getInstance`能确保是单例的，这是由于ThreadLocal内部实现了和如上容器注册方式一样的原理，使用到了map来存储已经创建的实例，可以参考源码`ThreadLocal.get()`，但是不同线程各自获取到的实例是不同的，此时就不是单例了。

## 1.9 总结

| 实现方式              | 懒加载 | 线程安全 | 性能             |
| --------------------- | ------ | -------- | ---------------- |
| 饿汉模式              | 否     | 是       | 高               |
| 懒汉模式              | 是     | 否       | 高               |
| 同步模式              | 是     | 是       | 低——synchronized |
| 双重检查锁            | 是     | 是       | 高               |
| 静态内部类            | 是     | 是       | 高               |
| 枚举模式              | 否     | 是       | 高               |
| 容器注册模式          | 是     | 是       | 低——synchronized |
| ThreadLocal单线程模式 | 是     | 否       | 高               |



