### STL中的sort
sort并非单一算法，而是一种根据数据量、数据分布和递归深度等因素智能选择最优排序策略的“内省式算法”。
| 数据规模               | 排序策略 | 平均时间复杂度             |
| ---------------------- | -------- | -------------------------- |
| 小数据量（<=16）       | 插入排序 | O(n²)，但常数项极低        |
| 中等数据量             | 快速排序 | O(n log n)                 |
| 大数据量或快排递归过深 | 堆排序   | O(n log n)，最坏情况有保障 |

- 混合策略：
1. 快速排序作为主力：对于大部分数据，使用分段递归的快速排序策略
2. 堆排序作为安全网：当快排递归深度超过 2*log(n)时，算法会察觉到快排可能会恶化，立即切换至堆排序
3. 插入排序处理尾部：当递归分段使子序列长度缩短到某个阈值，算法会对这些小序列采用插入排序，因为插入排序在近乎有序的小序列上的效率接近O(n)，且常数项开销极小。

### 注意事项：
1. sort是不稳定的
2. sort需要随机访问迭代器，不能用于list，list需要使用自己的成员函数sort

### sort为什么要使用混合排序，为什么不直接使用时间复杂度稳定的堆排序？
堆排序虽然拥有稳定的O(n logn)时间复杂度和O(1)的空间复杂度，但它有两个在实践中的主要弱点：
1. 缓存局部性差，堆排序在处理数据时，需要频繁地在数组不同位置进行比较和交换，这种跳跃式的内存访问模式不适合缓存预取
2. 虽然堆排序的时间复杂度为O(n logn)，但其常数项在实际中影响巨大，其实际运行时间通常显著长于快速排序