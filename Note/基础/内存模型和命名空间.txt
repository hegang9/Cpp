#include <iostream>
#include <string>
using namespace std;

/*
头文件常包含的内容：
函数原型。
使用#define或const定义的符号常量。
结构声明。
类声明。
模板声明。
内联函数。
*/

/*
三种静态持续变量的创建：
要想创建链接性为外部的静态持续变量，必须在代码块的外面声明它；即全局变量；
要创建链接性为内部的静态持续变量，必须在代码块的外面声明它，并使用static限定符；
要创建没有链接性的静态持续变量，必须在代码块内声明它，并使用static限定符。
*/

//关键字volatile可以理解为：在每次涉及到其修饰的变量时，均更新该变量的最新值
//关键字mutable可以用来指出，即使结构（或类）变量为const，其中被mutable修饰的某个成员也可以被修改

/*
在C++（但不是在C语言）中，const限定符对默认存储类型稍有影响。在默认情况下全局变量的链接性为外部的，但const全局变量的链接性为内部的。
也就是说，在C++看来，全局const定义就像使用了static说明符一样。
如果出于某种原因，程序员希望某个常量的链接性为外部的，则可以使用extern关键字来覆盖默认的内部链接性：
extern const int s=1;
*/

//可以使用关键字static将函数的链接性设置为内部的，使之只能在一个文件中使用。必须同时在原型和函数定义中使用该关键字

//定位new运算符语法:new (address) Type(constructor_arguments); 定位new函数不可替换，但可重载。

//名称空间可以是全局的，也可以位于另一个名称空间中，但不能位于代码块中。因此，在默认情况下，在名称空间中声明的名称的链接性为外部的（除非它引用了常量）
//名称空间是开放的，可以把名称加入到已有的名称空间中，使用下面语法添加：
namespace jill {
	int newInt;
}
//using声明：
using jill::newInt;
//using编译指令
using namespace jill;

//命名空间还可以嵌套：
namespace elements
{
	namespace fire
	{
		int flame;
	}
}
using namespace elements::fire;
using elements::fire::flame;

//也可以在名称空间中使用using编译指令和using声明,此时，被声明的变量同时属于两个命名空间，可以被两个命名空间一起访问
//命名空间可以使用=符号进行“起别名”的操作：
namespace j = jill;

//未命名的名称空间为静态内部链接性，只允许在当前文件中使用，提供了链接性为内部的静态变量的替代品，其中定义的变量相当于使用static修饰了


int main()
{

	return 0;
}