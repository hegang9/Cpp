# 类

## 类中的常量定义

### 方法一：使用枚举

```cpp
class Student {
private:
    enum { Month = 12 };
};
```

### 方法二：使用 static const

```cpp
class Student {
private:
    static const int month = 12;
    // 不能在类声明中初始化静态数据成员的一种例外情况：
    // 静态数据成员为整型 const 或枚举型 const
    // 否则类中声明的静态数据成员需要在类外（实现文件中）进行初始化
    static int mm;
};
```

## 作用域内枚举

```cpp
enum class egg { small, large };
enum class Tshirt { small, large };
```

**注意**：与传统枚举量不同，作用域内枚举量不能隐式转换为整型。

## 运算符重载

### 成员函数重载

```cpp
class Student {
public:
    Student operator+(const Student& a) const;
};

Student Student::operator+(const Student& a) const
{
    Student sum;
    sum.age = this->age + a.age;
    return sum;
}
```

### 友元函数重载

通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限。

使用友元函数对操作符进行重载，可以打破第一个操作数必须是类对象的限制。

```cpp
class Student {
public:
    friend ostream& getAge(ostream& os, const Student& a);
    friend Student operator+(int a, const Student& s);
};

Student operator+(int a, const Student& s)
{
    Student sum;
    sum.age = a * s.age;
    return sum;
}

ostream& getAge(ostream& os, const Student& a)
{
    os << a.age << endl;
    return os;
}
```

**注意**：友元函数不属于成员函数，不需要使用 `Student::` 修饰，定义时也不要加 `friend` 修饰。

## 不能重载的运算符

- `sizeof`：sizeof 运算符
- `.`：成员运算符
- `.*`：成员指针运算符
- `::`：作用域解析运算符
- `?:`：条件运算符
- `typeid`：一个 RTTI 运算符
- `const_cast`：强制类型转换运算符
- `dynamic_cast`：强制类型转换运算符
- `reinterpret_cast`：强制类型转换运算符
- `static_cast`：强制类型转换运算符

## 构造函数与析构函数

### 复制构造函数

每当程序生成了对象副本时，编译器都将使用复制构造函数。

```cpp
Student(const Student& s);
```

**默认的复制构造函数**逐个复制非静态成员（成员复制也称为浅复制），复制的是成员的值，即浅拷贝。

### 复制构造函数与赋值运算符的区别

| 项目 | 复制构造函数 | 赋值运算符 |
|------|------------|---------|
| 作用 | 创建一个新对象，初始化为已有对象的副本 | 将一个已有对象的值赋给另一个已存在的同类型对象 |
| 调用时机 | 创建新对象并用已有对象进行初始化时 | 对已存在的对象进行赋值操作时 |

### 赋值运算符重载

```cpp
Student& Student::operator=(const Student& other)
{
    if (this != &other) {  // 防止自赋值
        delete data;       // 释放原有资源
        data = new int(*other.data);
    }
    return *this;
}
```

### 虚析构函数

```cpp
virtual ~Student();
```

基类声明虚析构函数是为了确保释放派生对象时，按正确的顺序调用析构函数。这是一个惯例。

## 静态成员

### 静态成员函数

```cpp
static int getMonth();
```

- 不能使用 this 指针
- 如果在公有部分声明，可以使用类名和作用域解析运算符调用
- 只能使用静态数据成员

## 类继承

### 基类指针和引用

- 基类指针可以在不进行显式类型转换的情况下指向派生类对象
- 基类引用可以在不进行显式类型转换的情况下引用派生类对象
- 反之不行
- 基类指针或引用只能用于调用基类方法，不能调用派生类方法

### 公有派生

- 基类的公有成员将成为派生类的公有成员
- 基类的私有部分也将成为派生类的一部分，派生类不能直接访问
- 派生类不能直接访问基类的私有成员，但只能通过基类的公有和保护方法访问
- 派生类构造函数必须使用基类构造函数

### 虚函数

```cpp
virtual void print_vir();
```

- 如果没有使用关键字 `virtual`，程序将根据引用类型或指针类型选择方法
- 如果使用了 `virtual`，程序将根据引用或指针指向的对象的类型来选择方法

### 方法重新定义

重新定义继承的方法并不是重载。如果在派生类中重新定义函数，将不是使用相同的函数特征标覆盖基类声明，而是隐藏同名的基类方法。

**经验规则**：

1. 如果重新定义继承的方法，应确保与原来的原型完全相同，但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针（这种例外是新出现的）

2. 如果基类声明被重载了，则应在派生类中重新定义所有的基类版本。如果只重新定义一个版本，则其他的版本将被隐藏

## 抽象基类

抽象基类只定义接口，而不涉及实现，主要用于定义派生类的通用接口。

### 特点

- 必须包含至少一个纯虚方法
- 不能用来创建对象，只能用作基类

### 实现方法

在函数声明的结尾处添加 `= 0`，以表示此函数为纯虚函数。

```cpp
class VirtualBase {
public:
    virtual void pureVirtualFunc() = 0;
};
```
