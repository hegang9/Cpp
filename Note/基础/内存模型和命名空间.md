# 内存模型和命名空间

## 头文件常包含的内容

- 函数原型
- 使用 `#define` 或 `const` 定义的符号常量
- 结构声明
- 类声明
- 模板声明
- 内联函数

## 静态持续变量

### 三种创建方式

1. **链接性为外部的静态持续变量**
   - 必须在代码块的外面声明它
   - 即全局变量

2. **链接性为内部的静态持续变量**
   - 必须在代码块的外面声明它
   - 并使用 `static` 限定符

3. **没有链接性的静态持续变量**
   - 必须在代码块内声明它
   - 并使用 `static` 限定符

## volatile 和 mutable 关键字

### volatile

可以理解为：在每次涉及到其修饰的变量时，均更新该变量的最新值。

### mutable

用来指出，即使结构（或类）变量为 `const`，其中被 `mutable` 修饰的某个成员也可以被修改。

## const 全局变量的链接性

在 C++（但不是在 C 语言）中，`const` 限定符对默认存储类型稍有影响：

- 在默认情况下全局变量的链接性为**外部的**
- 但 **`const` 全局变量的链接性为内部的**
- 也就是说，在 C++ 看来，全局 `const` 定义就像使用了 `static` 说明符一样

### 覆盖默认链接性

如果出于某种原因，程序员希望某个常量的链接性为外部的，则可以使用 `extern` 关键字来覆盖默认的内部链接性：

```cpp
extern const int s = 1;
```

## 函数的链接性

可以使用关键字 `static` 将函数的链接性设置为**内部的**，使之只能在一个文件中使用。

必须同时在**原型和函数定义**中使用该关键字。

## 定位 new 运算符

### 语法

```cpp
new (address) Type(constructor_arguments);
```

**注意**：定位 new 函数不可替换，但可重载。

## 名称空间

### 基本特点

- 可以是全局的，也可以位于另一个名称空间中
- 但不能位于代码块中
- 在默认情况下，在名称空间中声明的名称的链接性为外部的（除非它引用了常量）
- 名称空间是开放的，可以把名称加入到已有的名称空间中

### 添加名称到已有命名空间

```cpp
namespace jill {
    int newInt;
}
```

### using 声明

```cpp
using jill::newInt;
```

### using 编译指令

```cpp
using namespace jill;
```

### 嵌套命名空间

```cpp
namespace elements {
    namespace fire {
        int flame;
    }
}

using namespace elements::fire;
using elements::fire::flame;
```

### 在命名空间中使用 using

也可以在名称空间中使用 `using` 编译指令和 `using` 声明，此时，被声明的变量同时属于两个命名空间，可以被两个命名空间一起访问。

### 命名空间起别名

```cpp
namespace j = jill;
```

## 未命名的命名空间

- 为静态内部链接性
- 只允许在当前文件中使用
- 提供了链接性为内部的静态变量的替代品
- 其中定义的变量相当于使用 `static` 修饰了
