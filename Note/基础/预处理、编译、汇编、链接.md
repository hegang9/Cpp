## 预处理阶段
#### 宏替换
预处理器会进行纯粹的文本替换，无类型检查，不推荐使用

#### 头文件展开
将头文件的全部内容原封不动地插入到include指令所在位置。如果被包含的文件自身还包含其他文件，这个过程会递归进行。

#### 条件编译
处理#if、#ifdef等条件编译指令。根据预定义的条件来决定保留哪些代码块

#### 删除注释
删除代码中所有注释

#### 处理特殊指令
处理如#error指令用于在满足某些条件时故意使编译中止并输出错误信息的特殊指令。

## 编译阶段：将预处理后的C++代码（.i 文件）翻译成汇编代码（.s 文件）
#### 词法分析
#### 语法分析
#### 语义分析
#### 中间代码生成与优化
#### 目标代码生成

## 汇编阶段：将编译阶段生成的汇编代码（.s 文件）翻译成机器可以直接执行的二进制机器码，并生成目标文件（.o 或 .obj 文件）
#### 逐句翻译
汇编器接收汇编代码，根据当前机器的指令集架构将每一条汇编指令翻译为对应的二进制机器码

#### 生成目标文件
输出的目标文件（.o）包含编译后的机器指令、操作数和一个**符号表**。符号表记录了在该目标文件中定义和引用（需要从其他文件解析）的函数和变量等信息。此时生成的目标文件还不能直接运行，因为它可能包含对外部函数或变量的引用，这些引用的地址在汇编阶段是未知的。

## 链接阶段：链接器将一个或多个目标文件（.o 文件）以及所需的静态库或动态库组合成一个单一的可执行文件​，其主要任务是解决不同目标文件之间的交叉引用
#### 符号解析
链接器收集所有输入目标文件中的符号（函数名、全局变量名等），构建一个全局符号表。当某个目标文件引用了另一个目标文件中定义的符号时，链接器负责在全局符号表中找到该符号的定义并将其与引用关联起来。如果找不到某个符号的定义，就会报“undefined reference”错误。

#### 地址重定位
在汇编阶段生成的目标文件中，代码和数据的地址通常是相对于文件开头的偏移量或临时地址。链接器会为所有目标文件中的代码段和数据段分配最终的内存加载地址，并据此调整所有符号引用处的地址，使其指向正确的内存位置。

#### 库文件处理
- 静态库链接：链接器将静态库（.a 或 .lib 文件）中需要用到的目标文件直接复制到最终的可执行文件中。优点是可执行文件独立性强，缺点是文件体积较大，且库更新后需重新链接。
- 动态库链接：链接器只在可执行文件中记录所需动态库（.so 或 .dll 文件）的名称和符号信息，而不复制库代码​ 。程序运行时，由**操作系统的动态链接器**将所需的库加载到内存并完成地址解析。优点是节省磁盘和内存空间，便于库更新，但可执行文件依赖于运行环境是否存在正确版本的库。

#### 生成可执行文件
链接器将合并和重定位后的代码、数据以及必要的运行时信息（如程序头）打包，生成最终的可执行文件

## 现代C++在这个编译链接中的处理
### 编译阶段的处理：
- lambda表达式：编译生成匿名类
- 函数重载：命名修饰，加一些前后缀区分不同的重载函数
- 动态多态：编译期生成虚函数表，初始化虚函数表指针
- 模板实例化：为每个模板实例生成独立的代码
- 类型推导：auto、decltype在编译期确定类型
- 内联函数：编译器将内联函数体插入
- 模板元编程：在编译阶段完成计算，不产生运行时开销
- 静态断言

### 链接阶段的处理：
- 内联变量（C++17）：在C++17之前，如果我们想在头文件中定义一个全局变量或类的静态成员变量，几乎肯定会遇到链接错误。因为当多个源文件包含这个头文件时，每个源文件都会包含该变量的一个定义，链接时会发现多个同名符号，违反“唯一定义规则（ODR）”。inline变量的引入，正是为了允许一个变量在多个编译单元中被定义，只要这些定义是完全相同的。链接器会确保在最终的程序中，这个变量只有一个实例。