# 指针

## 指针声明

### 注意事项

对每个指针变量名在声明时都要在其之前加一个 `*`。

```cpp
int* p1, p2;  // 这里 p1 是指针，p2 是 int 型变量
```

## 指针初始化

### 使用栈上的变量地址

```cpp
int a = 1;
int* pt = &a;  // 指针初始化，栈中分配内存
cout << pt << endl;
```

### 将整数地址赋值给指针

需要进行强制类型转换：

```cpp
pt = (int*)0xB8000000;
cout << pt << endl;
```

## 使用 new 分配内存

### 基本用法

```cpp
int* pt_1 = new int;  // new 将找到一个内存块并返回内存块的地址，堆中分配内存
*pt_1 = 100;
delete pt_1;  // 释放 pt_1 指向的内存
```

### delete 的特点

- 释放 `pt_1` 指向的内存，但不会删除 `pt_1` 指针
- 相当于将 `pt_1` 指针恢复到只声明没赋值的状态
- 后续还可以让 `pt_1` 指向一个新的内存块

### 常见错误

```cpp
// 不能使用 delete 释放由声明变量分配的内存
// delete pt;

// 不能对已经释放过的内存再次释放
// delete pt_1;
// delete pt_1;
```

## 动态数组

### 创建动态数组

```cpp
int* pt_2 = new int[2];
pt_2[0] = 1;
pt_2[1] = 2;
```

### 数组表示法访问

```cpp
cout << pt_2[0] << endl;  // 输出 1
cout << pt_2[1] << endl;  // 输出 2
```

### 指针表示法访问

```cpp
pt_2 += 1;
cout << *pt_2 << endl;    // 输出 2
```

### 删除动态数组

```cpp
pt_2 -= 1;  // 指针要指向数组的首元素
delete[] pt_2;
```

**重要**：`new[]` 在分配数组时，编译器会额外存储数组长度的元数据（通常位于数组起始地址之前）。当调用 `delete[]` 时，系统需要根据该元数据确定需要释放的内存范围。如果指针不指向首元素，将无法正确获取元数据，导致未定义行为（如内存泄漏或程序崩溃）。

## 指针和数组

### sizeof 运算符

```cpp
cout << sizeof(pt_2) << endl;  // 输出指针长度，64 位架构为 8，32 位架构为 4
```

**注意**：`sizeof` 作用于常规数组名会返回整个数组占用的字节长度。

### char 数组与 cout

```cpp
char flower[5] = "rose";
cout << flower << endl;  // 输出的是字符串 "rose"
```

**cout 对 char* 的特殊处理**：

当 `cout` 接收到 `char*` 类型的指针时，会将其视为 C 风格字符串的首地址，并输出从该地址开始的所有字符，直到遇到空终止符。

```cpp
int te[2] = { 0, 1 };
cout << te << endl;  // 输出的是一个地址，因为 int* 不是特殊的
```

## 指针和结构体

### 使用 -> 访问结构成员

使用 new 创建动态结构体时，通过 `->` 运算符访问成员。

```cpp
// struct MyStruct { int x; int y; };
// MyStruct* ptr = new MyStruct();
// ptr->x = 10;
// delete ptr;
```
