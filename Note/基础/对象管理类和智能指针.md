# 对象管理类和智能指针

## 智能指针简介

智能指针是 C++11 引入的一种特殊的指针类型，用于自动管理动态分配的内存（在堆中分配的内存）。它们可以帮助防止内存泄漏和悬空指针等问题。

C++ 标准库提供了三种主要的智能指针类型：`std::unique_ptr`、`std::shared_ptr` 和 `std::weak_ptr`。

在现代 C++ 中，原始指针仅用于范围有限的小代码块、循环或者性能至关重要且不会混淆所有权的 Helper 函数中。

### unique_ptr

- 不共享它的指针
- 它无法复制到其他 `unique_ptr`，无法通过值传递到函数，也无法用于需要副本的任何 C++ 标准库算法
- 只能移动 `unique_ptr`
- 这意味着，内存资源所有权将转移到另一 `unique_ptr`，并且原始 `unique_ptr` 不再拥有此资源
- 与 `boost::scoped_ptr` 比较，`unique_ptr` 小巧高效；大小等同于一个指针且支持 rvalue 引用，从而可实现快速插入和对 C++ 标准库集合的检索

### shared_ptr

- 采用引用计数的智能指针
- 如果你想要将一个原始指针分配给多个所有者（例如，从容器返回了指针副本又想保留原始指针时），请使用该指针
- 在您初始化一个 `shared_ptr` 之后，您可复制它，按值将其传入函数参数，然后将其分配给其他 `shared_ptr` 实例
- 所有实例均指向同一个对象，并共享对一个"控制块"（每当新的 `shared_ptr` 添加、超出范围或重置时增加和减少引用计数）的访问权限
- 直至所有 `shared_ptr` 所有者超出了范围或放弃所有权，才会删除原始指针
- 大小为两个指针；一个用于对象，另一个用于包含引用计数的共享控制块

### weak_ptr

- 结合 `shared_ptr` 使用的特例智能指针
- `weak_ptr` 提供对一个或多个 `shared_ptr` 实例拥有的对象的访问，但不参与引用计数
- 如果你想要观察某个对象但不需要其保持活动状态，请使用该实例
- 在某些情况下，需要断开 `shared_ptr` 实例间的循环引用
- 通过使用 `weak_ptr`，可以创建一个联接到现有相关实例集的 `shared_ptr`，但前提是基础内存资源仍然有效
- `weak_ptr` 本身不参与引用计数，因此，它无法阻止引用计数变为零
- 但是，可以使用 `weak_ptr` 尝试获取初始化该副本的 `shared_ptr` 的新副本
- 若已删除内存，则 `weak_ptr` 的 bool 运算符返回 false
- 若内存仍然有效，则新的共享指针会递增引用计数，并保证只要 `shared_ptr` 变量保留在作用域内，内存就会有效

## C++11 智能指针示例

```cpp
#include <iostream>
#include <string>
#include <memory>   // 智能指针头文件
using namespace std;

class LargeObject
{
public:
    void DoSomething() {}
};

void ProcessLargeObject(const LargeObject& lo) {}

void SmartPointerDemo()
{
    // Create the object and pass it to a smart pointer
    std::unique_ptr<LargeObject> pLarge(new LargeObject());

    // Call a method on the object
    pLarge->DoSomething();

    // Pass a reference to a method.
    ProcessLargeObject(*pLarge);

    ProcessLargeObject(*(pLarge.get())); // 使用 get() 方法获取原始指针

    pLarge.reset(); // 释放指针所有权，可以添加参数，参数为需要指向的新对象
}
```

## 使用智能指针的注意事项

1. **智能指针的生命周期**：智能指针的生命周期通常与其作用域相关。当智能指针超出作用域时，它所管理的对象会被自动销毁

2. **智能指针的类型选择**：根据需要选择合适的智能指针类型
   - `std::unique_ptr` 用于独占所有权
   - `std::shared_ptr` 用于共享所有权
   - `std::weak_ptr` 用于避免循环引用

3. **循环引用**：使用 `std::shared_ptr` 时要小心循环引用问题，这可能导致内存泄漏。可以使用 `std::weak_ptr` 来打破循环引用

4. **性能**：智能指针通常比原始指针稍慢，因为它们需要额外的开销来管理内存，但它们提供了更安全的内存管理

5. **创建方式**：始终在单独的代码行上创建智能指针，而绝不在参数列表中创建，这样做可以防止泄露资源

6. **避免误用**：不要对智能指针本身使用 `new` 或 `malloc` 表达式

7. **堆栈上的智能指针**：在堆栈上声明了智能指针，当智能指针超出范围时将调用其析构函数，尽管堆栈上的某处将进一步引发异常

## 创建并使用 unique_ptr

```cpp
void use_unique_ptr()
{
    // 第一种创建方法
    auto uniquePtr = make_unique<LargeObject>(new LargeObject());
    // 使用 make_unique 创建 unique_ptr，避免使用 new 关键字
    // make_unique 是 C++14 引入的，推荐使用它来创建 unique_ptr
    uniquePtr->DoSomething();

    // 第二种创建方法
    std::unique_ptr<LargeObject> anotherPtr = std::move(uniquePtr);
    // 转移所有权，转移后，uniquePtr 成为 nullptr
    // uniquePtr 在函数结束时自动释放

    auto arr = make_unique<int[]>(10); // 创建一个包含 10 个整数的 unique_ptr 数组
}
```

## 创建并使用 shared_ptr

```cpp
void use_shared_ptr()
{
    // 第一种创建方法
    auto sharedPtr = make_shared<LargeObject>(new LargeObject());
    // 使用 make_shared 创建 shared_ptr，避免使用 new 关键字
    // make_shared 是 C++14 引入的，推荐使用它来创建 shared_ptr
    sharedPtr->DoSomething();

    // 第二种创建方法
    std::shared_ptr<LargeObject> anotherSharedPtr = sharedPtr;
    // 共享所有权，anotherSharedPtr 和 sharedPtr 指向同一个对象

    // 第三种创建方法
    std::shared_ptr<LargeObject> thirdSharedPtr(new LargeObject());
    // 使用 new 关键字创建 shared_ptr，但不推荐
}
```
