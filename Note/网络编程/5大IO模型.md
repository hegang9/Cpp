# 五大IO模型
### 阻塞IO
当应用程序发起一个I/O调用（如read()）后，整个进程会被挂起（阻塞），直到内核将数据完全准备好并拷贝到用户空间缓冲区，调用才返回。

- 特点：编程模型简单。但效率极低，等待期间会浪费CPU资源

### 非阻塞IO
应用程序发起I/O调用后，内核立即返回一个状态（通常是EWOULDBLOCK或EAGAIN错误），而不会阻塞进程。应用程序需要反复轮询内核，检查数据是否就绪。

- 特点：进程在等待数据时不会被挂起，CPU可以执行其他任务。但轮询会消耗大量CPU时间，效率仍然不高

### IO多路复用（事件驱动IO）
通过select、poll、epoll等系统调用，同时监控多个文件描述符，当其中任何一个文件描述符就绪时，这些调用才返回。然后应用程序再进行实际的IO操作（这个操作本身通常是阻塞的）

- 特点：一个线程可以管理上百个文件描述符，极大地提升了资源利用率。编程模型比阻塞I/O复杂；在连接数较少且活跃度高时，性能可能不如传统的多线程阻塞模型
- 典型应用：Nginx, Redis, Java NIO, 以及绝大多数现代高性能网络服务

### 信号驱动IO
应用程序首先开启某个文件描述符的信号驱动模式，并注册一个信号处理函数。当内核数据准备就绪时，会向进程发送一个SIGIO信号。应用程序在信号处理函数中进行实际的I/O操作。

- 特点：在数据准备阶段完全不会阻塞。但信号处理编程复杂，信号队列可能溢出，可靠性不如IO多路复用
- 适用场景：特定低频、高实时性事件

### 异步IO
应用程序发起一个异步I/O请求（如aio_read），并指定一个回调函数或通知方式。调用立即返回，进程继续执行。内核会负责整个I/O过程（包括数据准备和数据从内核拷贝到用户空间）。当所有操作完成后，内核再通过指定的方式（如信号、回调线程）通知应用程序。

- 特点：从发起请求到收到结果，应用程序全程无阻塞，理论上效率最高。但编程模型最复杂；不同操作系统实现差异大
- 典型应用：Windows的IOCP


# 细节问题解答
### IO多路复用和信号驱动IO都是当就绪时通知应用程序，那么两者有何区别？
I/O多路复用是应用程序主动、集中地去内核查询一批文件描述符的状态；而信号驱动I/O是内核被动、分散地向应用程序发送信号通知单个文件描述符的事件。