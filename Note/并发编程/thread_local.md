### thread_local
- 定义：thread_local是 C++11 引入的一个强大的存储期说明符，用于实现线程局部存储（Thread-Local Storage, TLS）

| 作用域           | 声明示例                                        | 存储期与初始化                           | 关键特性                                      |
| ---------------- | ----------------------------------------------- | ---------------------------------------- | --------------------------------------------- |
| 全局变量         | thread_local int x = 1;                         | 线程存储期，每个线程首次访问时初始化     | 具有外部链接性，其他文件可通过 extern声明使用 |
| 局部变量         | void f() { thread_local int x = 1; }            | 线程存储期，线程内首次执行到声明时初始化 | 隐式具有静态存储期，但作用域仍限制在块内      |
| 类的静态成员变量 | class X { static thread_local std::string s; }; | 线程存储期，每个线程首次访问时初始化     | 必须使用 static关键字，并在类外单独定义       |

### thread_local的底层实现原理
操作系统和编译器协作，为每个线程分配一个专用的内存区域用于存放thread_local变量，这个内存区域通常位于线程栈之外的特殊段（例如.tdata），通过线程控制块（TLB）来管理该存储区的起始地址。
#### linux中的实现原理
- 在linux中，通过pthread库实现。pthread库为每个thread_local变量生成一个唯一的pthread_key_t。通过pthread_setspecific将一块数据（通常是在堆上分配的内存指针）与全局键 key绑定起来。在任何需要访问线程局部数据的地方，调用 pthread_getspecific，传入全局键 key。函数会返回此前在本线程中通过 pthread_setspecific设置的 value指针

### thread_local的局限性
- **不能用于非静态类成员变量**：对于类中的thread_local变量，必须是静态的，因为thread_local要求变量的生命周期与线程绑定，非静态成员变量的生命周期与类对象绑定；
- **不能用于lambda捕获**：thread_local变量具有静态存储期，可直接在Lambda体内访问，无需捕获。尝试捕获反而可能导致未定义行为；
- **thread_local变量不能作为函数参数传递**：对于按值传递，函数参数在每次调用时传递值，其生命周期是局部的，与thread_local变量的生命周期相悖。对于按引用传递，虽然语法上正确，但是会破坏thread_local的私有性。
- **不能跨线程传递其地址**：对 thread_local变量取地址获得的是当前线程实例的地址。一个线程的TLS地址在另一个线程的地址空间中没有意义，跨线程使用等于访问无效内存；且若父线程将某个thread_local变量的地址传递给子线程，而后父线程先于子线程结束，那么该地址将变为悬垂指针，导致未定义行为。
- **避免在全局作用域使用非编译期常量初始化**：非编译期常量（如函数返回值）在运行时初始化。若多个翻译单元存在这样的 thread_local变量，其初始化顺序不确定，可能引发静态初始化顺序问题