## C++异常
#### 异常处理三部曲
1. try语句探测异常：
    ```
    try{
        // 可能发生并抛出异常的代码
    }
    ```
2. throw抛出异常：
当检测到错误时，使用 throw关键字抛出一个异常对象。这个对象可以是任意**可拷贝构造**的类型，它携带了错误信息。（为什么要是可拷贝的类对象：异常对象（一个临时对象）被创建在一个**特殊的、独立的内存区域**（如**线程信息块TIB**中），如果异常对象不支持拷贝构造，而只是原始对象的一个引用或指针，那么抛出异常后控制流离开当前函数，导致该原始对象被析构，在上层控制块中访问该异常对象会导致未定义行为）
   ```
    double divide(int a, int b) {
        if (b == 0) {
            // 抛出一个标准异常对象，其中包含错误信息
            throw std::runtime_error("Division by zero!");
        }
        return static_cast<double>(a) / b;
    }
   ```
3. catch捕获并处理异常：
在 try块后紧跟一个或多个 catch块，用于捕获并处理特定类型的异常。捕获顺序一般遵循**先特殊后通用**
    ```
    try {
        double result = divide(10, 0);
    } catch (const std::runtime_error& e) { // 推荐使用 const 引用捕获
        std::cerr << "Caught an error: " << e.what() << std::endl;
    } catch (const std::exception& e) {     // 捕获更通用的标准异常
        // 处理其他标准异常
    } catch (...) {                         // 捕获所有未知类型的异常
        // 应谨慎使用，通常用于日志记录和资源清理
    throw; // 可重新抛出异常，交由更外层处理
    }
    ```
#### 自定义异常
C++标准库定义了一套异常体系，基类为 std::exception，它提供了 what()虚函数返回错误描述。建议自定义异常类从此基类派生
```
class my_exception:public std::exception{
private:
    std::string message;
public:
    my_exception(const string& msg):message(msg){}
    const char* what() const noexcept override{ // noexcept声明该函数不会抛出异常，这有助于编译器优化，如果函数意外抛出异常，程序会调用std::terminate()终止
        return message.c_str();
    }
}
```
#### 栈展开
栈展开（Stack Unwinding）是C++异常处理机制中一个非常关键且精妙的设计。它确保了当程序遇到意外错误时，能够安全、有序地“撤离”现场，避免资源泄漏。当异常被抛出（throw）时，程序的正常执行流程被中断，C++运行时系统会沿着函数的调用链，从异常抛出点开始逆向回溯，寻找能处理该异常的 catch块。在这个回溯过程中，系统会**自动销毁沿途各个函数栈帧中的局部对象**，以确保资源被正确释放。这也解释了**C++析构函数不应该抛出异常**的黄金法则，如果在栈展开的过程中某个局部对象的析构函数又抛出异常，C++无法同时处理两个异常，会立即调用std::terminate()终止程序。
   - 注意事项：对于手动分配内存的对象（new/delete），栈展开无法管理其内存空间，此时需要使用RAII将这些对象内存资源的生命周期与对象的生命周期绑定，以使栈展开机制能够正确回收内存。
