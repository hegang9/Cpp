## C++异常
#### 异常处理三部曲
1. try语句探测异常：
    ```c
    try{
        // 可能发生并抛出异常的代码
    }
    ```
2. throw抛出异常：
当检测到错误时，使用 throw关键字抛出一个异常对象。这个对象可以是任意**可拷贝构造**的类型，它携带了错误信息。（为什么要是可拷贝的类对象：异常对象（一个临时对象）被创建在一个**特殊的、独立的堆内存区域**（如**线程信息块TIB**中），如果异常对象不支持拷贝构造，而只是原始对象的一个引用或指针，那么抛出异常后控制流离开当前函数，导致该原始对象被析构，在上层控制块中访问该异常对象会导致未定义行为）
   ```c
    double divide(int a, int b) {
        if (b == 0) {
            // 抛出一个标准异常对象，其中包含错误信息
            throw std::runtime_error("Division by zero!");
        }
        return static_cast<double>(a) / b;
    }
   ```
3. catch捕获并处理异常：
在 try块后紧跟一个或多个 catch块，用于捕获并处理特定类型的异常。捕获顺序一般遵循**先特殊后通用**
    ```c
    try {
        double result = divide(10, 0);
    } catch (const std::runtime_error& e) { // 推荐使用 const 引用捕获
        std::cerr << "Caught an error: " << e.what() << std::endl;
    } catch (const std::exception& e) {     // 捕获更通用的标准异常
        // 处理其他标准异常
    } catch (...) {                         // 捕获所有未知类型的异常
        // 应谨慎使用，通常用于日志记录和资源清理
    throw; // 可重新抛出异常，交由更外层处理
    }
    ```
#### 自定义异常
C++标准库定义了一套异常体系，基类为 std::exception，它提供了 what()虚函数返回错误描述。建议自定义异常类从此基类派生
```c
class my_exception:public std::exception{
private:
    std::string message;
public:
    my_exception(const string& msg):message(msg){}
    const char* what() const noexcept override{ // noexcept声明该函数不会抛出异常，这有助于编译器优化，如果函数意外抛出异常，程序会调用std::terminate()终止
        return message.c_str();
    }
}
```
#### 栈展开
栈展开（Stack Unwinding）是C++异常处理机制中一个非常关键且精妙的设计。它确保了当程序遇到意外错误时，能够安全、有序地“撤离”现场，避免资源泄漏。当异常被抛出（throw）时，程序的正常执行流程被中断，C++运行时系统会沿着函数的调用链，从异常抛出点开始逆向回溯，寻找能处理该异常的 catch块。在这个回溯过程中，系统会**自动销毁沿途各个函数栈帧中的局部对象**，以确保资源被正确释放。这也解释了**C++析构函数不应该抛出异常**的黄金法则，如果在栈展开的过程中某个局部对象的析构函数又抛出异常，C++无法同时处理两个异常，会立即调用std::terminate()终止程序。
   - 注意事项：对于手动分配内存的对象（new/delete），栈展开无法管理其内存空间，此时需要使用RAII将这些对象内存资源的生命周期与对象的生命周期绑定，以使栈展开机制能够正确回收内存。

## 深入底层
#### 静态数据表：
当编译器遇到try和throw时，它并不会生成直接处理错误的指令流。相反，它会创建一套复杂的静态数据表，作为异常发生时运行时的“地图”。这套机制被称为零成本异常（Zero-cost Exception）​ 模型，其哲学是：在无异常发生的正常路径上，代码效率极高（几乎零开销）；仅当异常真正发生时，才付出查找和处理的开销。**静态数据表是栈展开的重要依赖**，主要包括以下两部分：
- **.eh_frame（异常处理帧）**：这个段存储了用于栈回退的指令，为每个**非noexcept函数**都创建了一个**帧描述项（FDE）**，用于告知系统如何回溯到调用当前函数的那个函数，其中记录了：
  - 当前函数的栈帧起始地址和范围
  - 返回地址保存在哪个寄存器的哪个偏移量处
  - 非易失性寄存器的保存位置
  - 如何根据当前PC恢复上一个栈帧的状态
- **LSDA（语言特定数据区）**：是C++语言的“异常处理专用附录”，它为每个函数记录：
  - 调用地 表：标识函数内部可能抛出异常的代码区域（如throw语句或可能抛出异常的函数调用），以及该区域对应的landing pad地址和异常类型信息，
  - 类型表：存储该函数的catch块**所能捕获的异常类型**的typedef指针

#### 栈展开的两个阶段：
1. 搜索：根据.eh_frame进行栈展开，每到一个栈帧，检查当前函数的LSDA，判断当前函数是否能够处理正在传播的异常，如果能，则记录匹配信息，否则继续展开并查找；
2. 清理：找到目标catch块后，展开器再次回到抛出点，进行**第二次栈展开**，执行流程会跳转到各个栈帧的Landing Pad执行清理操作。Landing Pad与栈展开交替进行，栈展开是引擎，Landing Pad是轮子。

#### Landing Pad：
连接栈展开和异常捕获的枢纽，是编译器在**函数内部生成并插入**的用于处理异常或执行清理的代码块，函数中的**每个try关键字都会触发生成一个对应的Landing Pad**，即使没有显式的try块，如果一个函数内定义了**具有非平凡析构函数的局部对象**，编译器也会生成对应的Landing Pad来确保发生异常时这些局部对象的非平凡析构函数被正确调用。Landing Pad 有三种类型：
- Cleanup Landing Pad：调用跳出作用域的局部对象的析构函数，执行完毕后会继续执行栈展开
- Catch Landing Pad：最终处理异常的地方，将传播的异常对象放到catch块可以访问到的位置，然后跳转到catch块中执行用户定义的异常处理代码，执行完毕后释放异常对象
- Rethrow Landing Pad：如果在catch块中又遇到了throw，则将异常再次向上抛出


## noexcept的影响：
noexcept关键字从根本上改变了编译器生成的代码和运行时的行为路径
- 声明为noexcept的函数，编译器不会或仅仅生成极简单的静态数据表，减小了二进制文件体积
- 如果一个noexcept函数抛出异常，系统会立即调用std::terminate()终止程序
- 对标准库行为的影响：举例说明，当一个vector进行扩容时，若对象的移动构造函数是noexcept的，则会**优先使用移动语义**；否则需要考虑异常发生，为了避免出现移动过程中已经掏空内存却没有移动成功造成内存泄漏，标准库会将此操作**回退至拷贝复制**。