### 左值和右值
- 左值：可以放在等号左边，可以取地址并有名字
- 右值：不能放在等号左边，不能取地址，没有名字

++i、--i是左值，i++、i--是右值（函数的返回值）

1. 右值引用与将亡值<br/>
将亡值是C++11新增的和右值引用相关的表达式。将亡值可以理解为即将要销毁的值，通过“盗取”其它变量**内存空间**方式获取的值，常用来完成**移动构造**或者**移动赋值**的特殊任务。右值引用是产生将亡值的语法基础。<br/>

   - 注意事项：在C++中，一个表达式是左值还是右值，取决于它“有没有标识符（名字）”以及“能否被取地址”，而**与其声明的类型（比如是不是X&&）没有直接关系**。例如以下代码中函数参数x虽然被声明为X&&类型，但是它还是一个左值;;
    ```c
    void foo(X&& x) { // x 是具名右值引用，所以是左值
        // 情况一：希望安全地使用x，不移动其资源
        useX(x); // 这会调用 useX(const X&) 或 useX(X&)，不会移动x

        // 情况二：明确希望将x的资源移动到另一个对象
        X newX = std::move(x); // 必须用std::move！这会调用移动构造函数
    }
    ```

2. 移动语义<br/>
可以理解为**转移所有权**，对于移动语义，类似于转让或者资源窃取的意思，对于那块资源，转为自己所拥有，别人不再拥有也不会再使用。<br/>
   - 使用方法：通过**移动构造函数**使用移动语义，也就是std::move；移动语义仅针对于那些**实现了移动构造函数的类的对象**，对于那种基本类型int、float等没有任何优化作用，还是会拷贝，因为它们实现没有对应的移动构造函数

3. 完美转发<br/>
写一个接受**任意实参**的函数模板，并转发到其它函数，目标函数会收到与转发函数**完全相同的实参**，通过std::forward()实现：<br/>
    ```c
    template <typename T>
    void wrapper(T&& arg) { // 注意：arg是一个具名变量，所以它在函数内部是左值！
    target_function(std::forward<T>(arg)); // 使用forward来保持arg原始的左右值属性
    }

    X x;
    wrapper(x); // 传递左值，target_function收到左值
    wrapper(X()); // 传递右值，target_function收到右值
    ```
    以上实现完美转发的关键点：
    - T&&是一个转发引用（也称**万能引用**），可以根据实参推导出是左值引用还是右值引用
    - 但无论推导结果如何，进入 wrapper 函数后，参数 arg都是一个有名字的变量，因此是左值
    - std::forward<T>(arg)的聪明之处在于，它能根据原始类型 T来决定是返回左值还是右值，从而完美地模拟了参数最初的类别

4. forward：C++11 引入的用于实现完美转发的关键工具，它能够在函数模板中保持参数的原始值类别（左值或右值）并将其正确转发给其他函数。本质上是一个有条件的 static_cast，它利用推导出的 T类型，通过引用折叠规则，将参数 arg还原为它传入时的原始值类别
    - 引用折叠规则：对于T&&通用引用作为函数参数时，编译器会根据传入的实参类型来推导T：
      - 如果传入一个左值，T会被推导成T&，那么T& &&会被折叠成T&，参数实际上是一个左值引用
      - 如果传入一个右值，T会被推导成T，T&&就是右值引用
```c
#include <iostream>
#include <utility>

// 目标函数，对左值和右值有不同的处理
void process(int& x)  { std::cout << "处理左值: " << x << "\n"; }
void process(int&& x) { std::cout << "处理右值: " << x << "\n"; }

// 包装函数模板：使用完美转发
template <typename T>
void wrapper(T&& arg) { // T&& 是通用引用，能匹配左值和右值
    // 使用 std::forward 保持 arg 的原始值类别
    process(std::forward<T>(arg));
}

int main() {
    int a = 10;
    wrapper(a);            // 传入左值 -> process(int&) 被调用
    wrapper(20);           // 传入右值 -> process(int&&) 被调用
    wrapper(std::move(a)); // 传入右值 -> process(int&&) 被调用
    // 注意：此后 a 的值可能已被移动，不应再使用
}
```