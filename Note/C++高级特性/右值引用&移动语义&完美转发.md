### 左值和右值
- 左值：可以放在等号左边，可以取地址并有名字
- 右值：不能放在等号左边，不能取地址，没有名字

++i、--i是左值，i++、i--是右值（函数的返回值）

1. **右值引用与将亡值**<br/>
将亡值是C++11新增的和右值引用相关的表达式。将亡值可以理解为即将要销毁的值，通过“盗取”其它变量**内存空间**方式获取的值，常用来完成**移动构造**或者**移动赋值**的特殊任务。右值引用是产生将亡值的语法基础。<br/>

   - 注意事项：在C++中，一个表达式是左值还是右值，取决于它“有没有标识符（名字）”以及“能否被取地址”，而**与其声明的类型（比如是不是X&&）没有直接关系**。例如以下代码中函数参数x虽然被声明为X&&类型，但是它还是一个左值;;
    ```c
    void foo(X&& x) { // x 是具名右值引用，所以是左值
        // 情况一：希望安全地使用x，不移动其资源
        useX(x); // 这会调用 useX(const X&) 或 useX(X&)，不会移动x

        // 情况二：明确希望将x的资源移动到另一个对象
        X newX = std::move(x); // 必须用std::move！这会调用移动构造函数
    }
    ```

2. **移动语义**<br/>
可以理解为**转移所有权**，对于移动语义，类似于转让或者资源窃取的意思，对于那块资源，转为自己所拥有，别人不再拥有也不会再使用。<br/>
   - 使用方法：通过**移动构造函数**使用移动语义，也就是std::move；移动语义仅针对于那些**实现了移动构造函数的类的对象**，对于那种基本类型int、float等没有任何优化作用，还是会拷贝，因为它们实现没有对应的移动构造函数

3. **完美转发**<br/>
写一个接受**任意实参**的函数模板，并转发到其它函数，目标函数会收到与转发函数**完全相同的实参**，通过std::forward()实现：<br/>
    ```c
    template <typename T>
    void wrapper(T&& arg) { // 注意：arg是一个具名变量，所以它在函数内部是左值！
    target_function(std::forward<T>(arg)); // 使用forward来保持arg原始的左右值属性
    }

    X x;
    wrapper(x); // 传递左值，target_function收到左值
    wrapper(X()); // 传递右值，target_function收到右值
    ```
    以下是实现完美转发的关键点：
    - T&&是一个**转发引用**（也称**万能引用**），可以根据实参推导出是左值引用还是右值引用
    - 但无论推导结果如何，进入 wrapper 函数后，参数 arg都是一个有名字的变量，因此是左值
    - std::forward<T>(arg)的聪明之处在于，它能根据原始类型 T来决定是返回左值还是右值，从而完美地模拟了参数最初的类别
    - 完美转发的实现依靠**万能引用、函数模板类型推导与引用折叠规则**，但要满足这些条件有着严苛的要求：
       - 首先，**实现完美转发的函数（如上述wrapper）必须是模板函数**，这样才能保证会进行类型推导
       - 其次，实**现完美转发的函数的参数类型必须是T&&**，只有这种格式才是万能引用
       - 最后，**任何对T&&格式的破坏都会导致万能引用退化为普通的右值引用**，从而使完美转发失效，例如对T&&加const修饰。

4. **forward**：C++11 引入的用于实现完美转发的关键工具，它能够在函数模板中保持参数的原始值类别（左值或右值）并将其正确转发给其他函数。本质上是一个有条件的 static_cast，它利用推导出的 T类型，通过引用折叠规则，将参数 arg还原为它传入时的原始值类别
```c
#include <iostream>
#include <utility>

// 目标函数，对左值和右值有不同的处理
void process(int& x)  { std::cout << "处理左值: " << x << "\n"; }
void process(int&& x) { std::cout << "处理右值: " << x << "\n"; }

// 包装函数模板：使用完美转发
template <typename T>
void wrapper(T&& arg) { // T&& 是通用引用，能匹配左值和右值
    // 使用 std::forward 保持 arg 的原始值类别
    process(std::forward<T>(arg));
}

int main() {
    int a = 10;
    wrapper(a);            // 传入左值 -> process(int&) 被调用
    wrapper(20);           // 传入右值 -> process(int&&) 被调用
    wrapper(std::move(a)); // 传入右值 -> process(int&&) 被调用
    // 注意：此后 a 的值可能已被移动，不应再使用
}
```

5. move函数原型
```c
// C++11 及以后的基本定义
template <typename T>
constexpr typename std::remove_reference<T>::type&& move(T&& t) noexcept {
    return static_cast<typename std::remove_reference<T>::type&&>(t);
}

// C++14 风格写法
template <typename T>
constexpr std::remove_reference_t<T>&& move(T&& t) noexcept {
    return static_cast<std::remove_reference_t<T>&&>(t);
}
```
- 解释:
  - std::remove_reference<T>::type是一个类型萃取模板，其作用是移除类型T可能带有的引用属性，得到最基本的类型如int、short（不会移除其它属性，只移除引用）
  - 得到基础类型后，通过添加&&无条件地返回右值引用

6. forward函数原型
```c
// 重载1：用于左值
template <class T>
constexpr T&& forward(typename std::remove_reference<T>::type& t) noexcept {
    return static_cast<T&&>(t);
}

// 重载2：用于右值
template <class T>
constexpr T&& forward(typename std::remove_reference<T>::type&& t) noexcept {
    static_assert(!std::is_lvalue_reference<T>::value, "Bad forward call");
    return static_cast<T&&>(t);
}
```