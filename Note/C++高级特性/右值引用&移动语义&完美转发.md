### 左值和右值
- 左值：可以放在等号左边，可以取地址并有名字
- 右值：不能放在等号左边，不能取地址，没有名字

++i、--i是左值，i++、i--是右值（函数的返回值）

1. 右值引用与将亡值<br/>
将亡值是C++11新增的和右值引用相关的表达式。将亡值可以理解为即将要销毁的值，通过“盗取”其它变量**内存空间**方式获取的值，常用来完成**移动构造**或者**移动赋值**的特殊任务。右值引用是产生将亡值的语法基础。<br/>

   - 注意事项：在C++中，一个表达式是左值还是右值，取决于它“有没有标识符（名字）”以及“能否被取地址”，而**与其声明的类型（比如是不是X&&）没有直接关系**。例如以下代码中函数参数x虽然被声明为X&&类型，但是它还是一个左值;;
    ```
    void foo(X&& x) { // x 是具名右值引用，所以是左值
        // 情况一：希望安全地使用x，不移动其资源
        useX(x); // 这会调用 useX(const X&) 或 useX(X&)，不会移动x

        // 情况二：明确希望将x的资源移动到另一个对象
        X newX = std::move(x); // 必须用std::move！这会调用移动构造函数
    }
    ```

2. 移动语义<br/>
可以理解为**转移所有权**，对于移动语义，类似于转让或者资源窃取的意思，对于那块资源，转为自己所拥有，别人不再拥有也不会再使用。<br/>
   - 使用方法：通过**移动构造函数**使用移动语义，也就是std::move；移动语义仅针对于那些**实现了移动构造函数的类的对象**，对于那种基本类型int、float等没有任何优化作用，还是会拷贝，因为它们实现没有对应的移动构造函数

3. 完美转发<br/>
写一个接受**任意实参**的函数模板，并转发到其它函数，目标函数会收到与转发函数**完全相同的实参**，通过std::forward()实现：<br/>
    ```
    template <typename T>
    void wrapper(T&& arg) { // 注意：arg是一个具名变量，所以它在函数内部是左值！
    target_function(std::forward<T>(arg)); // 使用forward来保持arg原始的左右值属性
    }

    X x;
    wrapper(x); // 传递左值，target_function收到左值
    wrapper(X()); // 传递右值，target_function收到右值
    ```
    以上实现完美转发的关键点：
    - T&&是一个转发引用（也称**万能引用**），可以根据实参推导出是左值引用还是右值引用
    - 但无论推导结果如何，进入 wrapper 函数后，参数 arg都是一个有名字的变量，因此是左值
    - std::forward<T>(arg)的聪明之处在于，它能根据原始类型 T来决定是返回左值还是右值，从而完美地模拟了参数最初的类别
