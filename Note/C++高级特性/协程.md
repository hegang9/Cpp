## 有栈协程（以使用ucontext实现的有栈协程为例）
有栈协程通过**切换完整的运行时上下文**来实现挂起和恢复，ucontext组件是包含四个关键函数和两个核心结构体，它们共同构成了有栈协程的基石：

| 函数/结构体                                                      | 核心职责                                                                                                       |
| ---------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------- |
| int getcontext(ucontext_t *ucp)                                  | 捕获当前CPU的运行时状态（如程序计数器、栈指针、寄存器），并将其保存到ucp中                                     |
| void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...) | 初始化或修改一个上下文ucp，为其绑定一个具体的执行函数func​ 及其参数，并设置好运行时所使用的栈                  |
| int setcontext(const ucontext_t *ucp)                            | 激活ucp所代表的上下文。CPU将开始执行该上下文关联的函数，通常不返回​                                            |
| int swapcontext(ucontext_t *oucp, ucontext_t *ucp)               | 原子操作：先将当前状态保存到oucp，然后激活ucp。这是实现协程切换最常用的函数                                    |
| ucontext_t结构体                                                 | 上下文的抽象容器，核心成员包括：uc_stack（栈信息）、uc_link（后继上下文）、uc_mcontext（机器相关的寄存器状态） |
| mcontext_t结构体                                                 | 与CPU架构密切相关的机器上下文，保存了所有关键寄存器的值，通常不直接操作                                        |

#### 有栈协程从创建到运行再到挂起和恢复的流程图：

<img src="image.png" width="300" />

#### 有栈协程的关键特性：
1. 独立栈空间：每个协程都有自己独立的栈，因此可以在其内部进行正常的函数调用、递归等，而不会与其他协程冲突。这是与无栈协程（依赖状态机）的根本区别；
2. 协作式调度：协程之间的切换是**协作式**的，而非抢占式。一个协程必须主动调用yield（或类似函数）让出执行权，调度器才能运行另一个协程；
3. 上下文切换的底层操作：swapcontext在底层不仅保存和恢复通用寄存器、指令指针（RIP），更重要的是会切换栈指针（RSP）。这使得CPU在切入协程时，能立即使用为其分配的独立栈；切出时，又能准确回到主调度器的栈帧 

#### 有栈协程的本质：
利用ucontext实现有栈协程，本质上是**通过软件手段，在用户态模拟多个线程的执行环境**。

## 无栈协程
无栈协程在“并发编程/coroutine”中已经有介绍，这里仅仅将其与有栈协程进行比较：

| 比较维度   | 有栈                                            | 无栈                                                            |
| ---------- | ----------------------------------------------- | --------------------------------------------------------------- |
| 栈管理     | 每个协程有独立的、预先分配的用户栈空间          | 无独立栈，局部变量保存在堆上的协程帧                            |
| 内存开销   | 栈空间固定且通常较大，可能发生浪费和溢出        | 开销小且灵活，仅保存必要状态，可创建大量协程                    |
| 挂起灵活性 | 非常灵活，可在任意函数嵌套深度挂起              | 受限，只能在协程函数顶层直接挂起                                |
| 性能特点   | 上下文切换涉及大量寄存器/内存操作，开销相对较大 | 切换近似函数调用，效率极高，可达纳秒级                          |
| 编程模型   | 更接近**用户态线程**，支持对称或非对称协程          | 非对称协程为主，通过co_await将控制权返回给调用者/恢复者         |
| 易用性     | API相对直接，但需手动管理栈和上下文             | 底层机制复杂，需理解promise_type、awaiter等概念，通常依赖库封装 |

## 补充：对称协程和非对称协程
| 特性维度   | 对称协程                                 | 非对称协程                           |
| ---------- | ---------------------------------------- | ------------------------------------ |
| 控制权转移 | 直接、自由转移                           | 必须通过固定的调用者中转             |
| 角色关系   | 所有协程地位平等                         | 存在调用层级，协程从属于调用者       |
| 编程模型   | 更灵活，但也更接近goto，流程可能复杂难控 | 更结构化，逻辑清晰，类似普通函数调用 |