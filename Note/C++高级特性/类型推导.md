### 类型推导
### auto：
auto可以在让编译器在编译期就推导出变量的类型，**auto是一个类型占位符，而非动态类型**。
#### auto注意事项如下：
- auto的使用必须马上初始化，否则无法推导出类型
  
- auto在一行定义多个变量时，各个变量的推导不能产生二义性，即所有变量必须是同一类型，编译器实际上只对第一个变量的初始化表达式进行类型推导，然后将此结果应用于同语句中的其他变量。如果变量类型不同，会发生编译错误。
  
- 在C++20之前，auto不能用作函数参数；C++20引入简写函数模板，auto用作函数参数与函数模板等价：
    ```c
    void func(auto param)

    template <typename T> void func(T param)
    ```

- 在类中auto不能用作非静态成员变量。类的定义需要确定每个成员的大小和布局。如果允许非静态成员使用auto，如auto m_value = 10;，那么在类定义时，编译器无法确定m_value的类型（它可能因不同的构造函数初始化列表而不同，即可能会被构造函数初始化为其他类型），这会破坏类的内存布局稳定性。静态常量成员（static const auto value = 10;）是允许的，因为其初始化在编译期即可确定。 
 
- auto不能定义数组，可以定义指针。当用一个数组去初始化一个auto变量时，会发生**数组到指针的退化**。若希望保留数组类型，需要使用引用：auto& ref=arr，此时ref的类型是int(&)[10];

- 在C++17之前，auto无法推导非类型模板参数；C++17标准允许auto作为非类型模板参数，例如template<auto N> struct S{};，此时N的类型和值由实例化时提供的实参推导。
  
- 分为按值推导和按引用/指针推导，按值推导不会保留引用、const、volatile属性：
    ```c
    // 按值推导：
    const int ci = 10;
    volatile int di=9;
    int& ri = ci;
    auto a = ci; // a 是 int，const 被忽略
    auto c = di; // c 是 int，volatile被忽略
    auto b = ri; // b 是 int，引用被忽略，复制了ri引用的值

    // 按引用/指针推导：
    const int ci = 10;
    auto& ra = ci; // ra 是 const int&
    auto* pa = &ci; // pa 是 const int*
    // 同理volatile属性也会保留
    ```

- C++14支持auto推导函数返回值,但推导规则与值推导一样，会剥离引用和cv属性，要实现保留这些属性，需要完美转发，需要使用decltype(auto)，见下文

- **注意：auto类型推导会保留底层const属性，丢弃顶层const属性：**
```c++
int a=1;
const int* p1=&a;
auto p2=p1; // 这里会推导出const int*，保留底层const属性

int* const p3=&a;
auto p4=p3; //这里会推导出int*，丢弃顶层const属性
```

#### auto引用用法：
- auto& 与常规引用相同，只是加了一个类型推导，会**保留cv属性**，同时**数组也不会退化**，而是直接推导出数组类型。相当于给变量设置一个别名。
- auto&& 在推导左值时与auto& 一样推导出左值引用，在推导右值时，推导出右值引用，**保留cv属性，数组不退化**，主要用于实现泛型编程和完美转发：
  ```c++
    template<typename T>
    void wrapper(T&& param){
        auto&& local=std::forward<T>(param);
    }
  ```

### decltype：
decltype是C++11引入的关键字，用于在编译时查询表达式或实体的类型。它不计算表达式的值，只进行类型分析。并且**会保留引用和cv属性**.<br/>
#### decltype规则如下：
- 标识符与类成员访问：如果表达式是一个没有括号的变量名或类成员访问，直接返回该实体的声明类型：
    ```c
    int i;
    const int ci = 0;
    int& ref = i;
    struct A { double x; } a;

    decltype(i) var1;       // int
    decltype(ci) var2 = 10; // const int，必须初始化
    decltype(ref) var3 = i; // int&，必须初始化并绑定到变量i
    decltype(a.x) var4;     // double
    ```

- 左值表达式与括号：如果表达式是左值（即有名字的、可取地址的表达式），并且不是上述的简单标识符（通常是因为加了括号），decltype将产生一个左值引用类型（T&）：
    ```c
    int j = 0;
    decltype(j) a = j;   // 规则1：j是标识符，a 是 int
    decltype((j)) b = j; // 规则3：(j)是左值表达式，b 是 int&，必须绑定到j
    ```
    像 ++i（返回左值）、*ptr（解引用）、arr[0]（数组下标）等返回左值的表达式，decltype推导结果也都是引用类型

- 纯右值和将亡值：如果表达式是纯右值（如字面量、临时对象、函数的按值返回结果）或将亡值（如 std::move的结果），decltype产生该表达式本身的类型（非引用）：
    ```c
    decltype(42) var5;          // int，字面量是纯右值
    decltype(func()) var6;      // 假设func返回int，则var6是int（返回的是临时对象，纯右值）
    decltype(std::move(j)) var7 = std::move(j); // int&&右值引用，必须绑定到右值
    ```

#### decltype高级用法：
- 函数返回类型推导（尾置返回类型）：当**函数的返回类型依赖于参数**时（尤其在C++11中），可以使用 auto ... -> decltype(...)的语法来声明返回类型：
    ```c
    template <typename T, typename U>
    auto add(T t, U u) -> decltype(t + u) 
    {
        return t + u;
    }
    ```
    auto ... -> decltype(...) 是 decltype(*(T*)0 + *(U*)0)的一个语法糖，用于提升可读性。
- C++14 允许直接使用 auto推导函数返回类型，但对于需要完美转发返回类型（包括引用和cv限定符）的场景，应使用 decltype(auto)。decltype(auto)是一个固定搭配，专门用于实现函数返回值的完美转发。如果需要再C++11中实现完美转发，需要通过auto ... -> decltype(...)实现:
    ```c
    const int& getRef(const int* p) { return *p; }

    auto getRefFwdBad(const int* p) { return getRef(p); } 
    // 返回类型是 int，而非 const int&（auto去掉了引用和const）

    decltype(auto) getRefFwdGood(const int* p) { return getRef(p); } 
    // 返回类型是 const int&，与getRef完全一致。
    ```
    ```c
    template<typename Container, typename Index>
    auto access(Container& c, Index i) -> decltype(c[i]) 
    {
        return c[i];
    }
    ```
