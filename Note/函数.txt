#include <iostream>
#include <string>
using namespace std;


//内联函数，使用相应的函数代码替换函数调用，增大了内存但减小了时间开销
/*
使用要求：（两个条件选一个）
1、在函数声明前加上关键字inline；
2、在函数定义前加上关键字inline。
*/

//引用变量必须在声明引用变量时进行初始化
//常规（非引用）返回类型是右值——不能通过地址访问的值，而引用返回类型是可修改的左值，若不想允许对引用返回值的赋值，需将返回值设置为const
//非常量引用不能指向其他类型，常量引用可以指向其他类型，原因如下：（以int变量赋值给double型引用为例）
//​隐式转换过程​：int到double的转换会生成一个临时double对象（例如static_cast<double>(a)），但临时对象默认是右值（无法修改的临时值）。
​//引用的权限限制​：非const引用（如double& ）要求直接修改原对象，而临时对象无法被直接修改，因此编译器禁止这种操作以规避潜在的逻辑错误。

//引用使用原则：
/*
对于使用传递的值而不作修改的函数。
如果数据对象很小，如内置数据类型或小型结构，则按值传递。
如果数据对象是数组，则使用指针，因为这是唯一的选择，并将指针声明为指向const的指针。
如果数据对象是较大的结构，则使用const指针或const引用，以提高程序的效率。这样可以节省复制结构所需的时间和空间。
如果数据对象是类对象，则使用const引用。类设计的语义常常要求使用引用，这是C++新增这项特性的主要原因。
因此，传递类对象参数的标准方式是按引用传递。

对于修改调用函数中数据的函数：
如果数据对象是内置数据类型，则使用指针。如果看到诸如
fixit（&x）这样的代码（其中x是int），则很明显，该函数将修改x。
如果数据对象是数组，则只能使用指针。
如果数据对象是结构，则使用引用或指针。
如果数据对象是类对象，则使用引用。
*/

//对于带参数列表的函数，必须从右向左添加默认值。也就是说，要为某个参数设置默认值，则必须为它右边的所有参数提供默认值
/*
函数重载的关键是函数的参数列表——也称为函数特征标。
如果两个函数的参数数目和类型相同，同时参数的排列顺序也相同，则它们的特征标相同，而变量名和返回值是无关紧要的。
C++允许定义名称相同的函数，条件是它们的特征标不同。如果参数数目和或参数类型不同，则特征标也不同。

但是需要注意：
类型引用和类型本身视为同一个特征标
const和非const是不同的特征标
*/

//函数模板声明和定义：(函数模板也可以进行重载)
template <typename T>//这里的typename可以替换为class
void swap(T a, T b);

template <typename T>
void swap(T a, T b) 
{
	return;
}

/*
对于给定的函数名，可以有非模板函数、模板函数和显式具体化模板函数以及它们的重载版本。
显式具体化的原型和定义应以template<>打头，并通过名称来指出类型。
具体化优先于常规模板，而非模板函数优先于具体化和常规模板
*/

//显式具体化示例：（显式具体化必须给出新的函数体）
template<> void swap(int s, int b) {
	return;
}
template<> void swap<int>(int s, int b) {
	return;
}

//与显式具体化不同，显式实例化是通知编译器根据模板实例化一个函数定义，语法如下：
template void swap<int>(int a, int b);//显式实例化不能写函数体，因为函数体已经在函数模板中定义了，这个语法与显式具体化就在template后少了个<>

//试图在同一个文件（或转换单元）中使用同一种类型的显式实例和显式具体化将出错。


const int& Play(const int& i,int& ans) {
	ans = i * i;
	return ans;
}

int main()
{
	int i = 8;
	int ans = 0;
	cout << Play(i, ans) << endl;

	return 0;
}