### 进程创建方法
使用fork()系统调用创建进程，遵循“写时复制”机制

### 写时复制机制
fork()后，父子进程的代码段、全局变量、堆内存、栈内存等初始共享同一物理内存页，但被内核标记为只读。当任一进程尝试写入时，会触发缺页异常，内核此时才会为该进程复制一份新的物理页供其修改，从而保持隔离

### 父子进程共享的资源
| 资源类别                 | 是否共享 | 描述                                                                                                                                                                       |
| ------------------------ | -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 内存空间（数据段和堆栈） | 写时复制 | 见上文                                                                                                                                                                     |
| 打开的文件描述符         | 是       | 子进程会获得父进程文件描述符表的副本，这意味着它们指向相同的打开文件描述。因此，父子进程共享文件偏移量。<br>对同一个文件进行读写操作时，如果不进行同步，输出可能会相互混合 |
| 信号处理方式             | 是       | 子进程会继承父进程为各信号设置的处置方式                                                                                                                                   |
| 进程凭证                 | 是       | 实际/有效用户ID、实际/有效组ID、附加组ID、进程组ID、会话ID等都会被继承                                                                                                     |
| 文件系统相关属性         | 是       | 当前工作目录、根目录、文件模式创建屏蔽字会被子进程继承                                                                                                                     |
| 信号量调整值             | 是       | 对某个信号设定的信号量调整值会被继承                                                                                                                                       |
| 进程ID                   | 否       | 子进程拥有全新且唯一的ID                                                                                                                                                   |
| 文件锁                   | 否       | 父进程设置的锁不会被继承                                                                                                                                                   |
| 待处理信号               | 否       | 子进程会清空待处理的信号集                                                                                                                                                 |

由于父子进程的文件描述符表是相同的，所以在对共享的文件进行读写时，一定要使用同步机制（锁、信号量）来避免竞态条件

---

### 进程同步方法

进程同步是指多个进程在访问共享资源或进行协作时，通过特定机制保证操作的有序性和一致性，防止竞态条件和数据混乱。

---

#### 1. 信号量（semaphore）
**原理**：信号量是内核维护的计数器，支持P（等待）和V（释放）操作。可实现互斥（初值1）或资源计数（初值N）。
**优点**：通用、可跨进程、支持复杂同步。
**缺点**：易用性不如高层封装，易出错（如死锁、信号量泄漏）。
**典型场景**：生产者-消费者、进程互斥、资源池。
```c
#include <semaphore.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdio.h>
// 父子进程同步示例
int main() {
	sem_t sem;
	sem_init(&sem, 1, 0); // 1: 进程间可见，初值0
	pid_t pid = fork();
	if (pid == 0) {
		// 子进程
		printf("child: working...\n");
		sem_post(&sem); // 通知父进程
	} else {
		sem_wait(&sem); // 等待子进程完成
		printf("parent: child done\n");
		wait(NULL);
	}
	sem_destroy(&sem);
	return 0;
}
```

---

#### 2. 互斥锁（mutex）
**原理**：保证同一时刻只有一个进程能进入临界区。需分配在共享内存中，并设置为PTHREAD_PROCESS_SHARED。
**优点**：简单高效，适合保护小粒度共享数据。
**缺点**：仅适合互斥，不能实现计数型同步。
**典型场景**：多进程安全递增计数器。
```c
#include <pthread.h>
#include <sys/mman.h>
#include <unistd.h>
#include <stdio.h>
// 共享内存互斥锁示例
int main() {
	void* addr = mmap(NULL, sizeof(pthread_mutex_t)+sizeof(int),
					  PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);
	pthread_mutex_t* mtx = (pthread_mutex_t*)addr;
	int* counter = (int*)(mtx+1);
	pthread_mutexattr_t attr;
	pthread_mutexattr_init(&attr);
	pthread_mutexattr_setpshared(&attr, PTHREAD_PROCESS_SHARED);
	pthread_mutex_init(mtx, &attr);
	if (fork() == 0) {
		for (int i=0; i<10000; ++i) {
			pthread_mutex_lock(mtx);
			++(*counter);
			pthread_mutex_unlock(mtx);
		}
		_exit(0);
	} else {
		for (int i=0; i<10000; ++i) {
			pthread_mutex_lock(mtx);
			++(*counter);
			pthread_mutex_unlock(mtx);
		}
		wait(NULL);
		printf("counter=%d\n", *counter); // 期望20000
	}
	pthread_mutex_destroy(mtx);
	return 0;
}
```

---

#### 3. 文件锁（flock/fcntl）
**原理**：直接加锁文件，支持独占锁（写锁）和共享锁（读锁）。
**优点**：简单、可用于任意进程间。
**缺点**：仅适合文件，粒度较大。
**典型场景**：多进程写同一日志文件。
```c
#include <sys/file.h>
#include <unistd.h>
#include <stdio.h>
#include <fcntl.h>
// flock加锁写文件示例
int main() {
	int fd = open("test.txt", O_CREAT|O_WRONLY, 0644);
	flock(fd, LOCK_EX); // 加独占锁
	write(fd, "hello\n", 6);
	sleep(2); // 模拟长时间写
	flock(fd, LOCK_UN); // 解锁
	close(fd);
	return 0;
}
```

---

#### 4. 管道/消息队列
**原理**：管道（pipe）和消息队列用于进程间通信，也可实现同步。管道写满/读空时会阻塞，天然同步。
**优点**：通信+同步一体，适合生产者-消费者。
**缺点**：仅适合数据流同步，不能直接实现互斥。
**典型场景**：父子进程事件通知。
```c
#include <unistd.h>
#include <stdio.h>
// 无名管道同步示例
int main() {
	int fd[2];
	pipe(fd);
	if (fork() == 0) {
		close(fd[0]);
		write(fd[1], "X", 1); // 通知父进程
	} else {
		close(fd[1]);
		char buf;
		read(fd[0], &buf, 1); // 阻塞直到收到通知
		printf("parent: child notified\n");
	}
	return 0;
}
```

---

#### 5. 共享内存 + 信号量/锁
**原理**：多进程通过shmget/shmat等共享一块内存，需配合信号量/互斥锁保证同步。
**优点**：高效，适合大数据量共享。
**缺点**：同步复杂，需手动管理生命周期。
**典型场景**：多进程共享数据区。
```c
#include <sys/ipc.h>
#include <sys/shm.h>
#include <semaphore.h>
#include <unistd.h>
#include <stdio.h>
// 共享内存+信号量同步示例
struct Shared {
	sem_t sem;
	int data;
};
int main() {
	int shmid = shmget(IPC_PRIVATE, sizeof(struct Shared), IPC_CREAT|0666);
	struct Shared* shm = (struct Shared*)shmat(shmid, NULL, 0);
	sem_init(&shm->sem, 1, 0);
	if (fork() == 0) {
		shm->data = 42;
		sem_post(&shm->sem); // 通知父进程
		_exit(0);
	} else {
		sem_wait(&shm->sem); // 等待子进程写入
		printf("parent: data=%d\n", shm->data);
		wait(NULL);
	}
	sem_destroy(&shm->sem);
	shmdt(shm);
	shmctl(shmid, IPC_RMID, NULL);
	return 0;
}
```

---

#### 6. 条件变量
**原理**：条件变量允许进程在条件不满足时阻塞等待，配合互斥锁使用。需分配在共享内存中，并设置为PTHREAD_PROCESS_SHARED。
**优点**：适合复杂同步场景（如多进程生产者-消费者）。
**缺点**：使用复杂，需正确初始化和销毁。
**典型场景**：多进程同步状态。
```c
#include <pthread.h>
#include <sys/mman.h>
#include <unistd.h>
#include <stdio.h>
// 共享内存条件变量同步示例
struct Shared {
	pthread_mutex_t mtx;
	pthread_cond_t cond;
	int ready;
};
int main() {
	struct Shared* shm = mmap(NULL, sizeof(struct Shared),
		PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0);
	pthread_mutexattr_t mattr;
	pthread_condattr_t cattr;
	pthread_mutexattr_init(&mattr);
	pthread_condattr_init(&cattr);
	pthread_mutexattr_setpshared(&mattr, PTHREAD_PROCESS_SHARED);
	pthread_condattr_setpshared(&cattr, PTHREAD_PROCESS_SHARED);
	pthread_mutex_init(&shm->mtx, &mattr);
	pthread_cond_init(&shm->cond, &cattr);
	shm->ready = 0;
	if (fork() == 0) {
		pthread_mutex_lock(&shm->mtx);
		shm->ready = 1;
		pthread_cond_signal(&shm->cond); // 通知父进程
		pthread_mutex_unlock(&shm->mtx);
		_exit(0);
	} else {
		pthread_mutex_lock(&shm->mtx);
		while (!shm->ready)
			pthread_cond_wait(&shm->cond, &shm->mtx); // 等待条件
		pthread_mutex_unlock(&shm->mtx);
		printf("parent: child ready\n");
		wait(NULL);
	}
	pthread_mutex_destroy(&shm->mtx);
	pthread_cond_destroy(&shm->cond);
	munmap(shm, sizeof(struct Shared));
	return 0;
}
```

---

#### 示例：使用 POSIX 信号量实现进程同步
```c
#include <semaphore.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdio.h>

int main() {
		sem_t sem;
		sem_init(&sem, 1, 0); // 1 表示进程间可见，初值为0
		pid_t pid = fork();
		if (pid == 0) {
				// 子进程
				printf("child: do something...\n");
				sem_post(&sem); // 通知父进程
		} else {
				sem_wait(&sem); // 等待子进程完成
				printf("parent: child done, continue...\n");
				wait(NULL);
		}
		sem_destroy(&sem);
		return 0;
}
```

#### 注意事项
- 进程同步原语通常需要操作系统内核支持，不能直接用线程库的同步对象。
- 进程间同步常见 bug 包括：未初始化/销毁同步对象、信号量泄漏、死锁等。
- 多进程共享资源时，务必保证所有访问路径都加同步。

### 进程资源清理
子进程退出后，其占用的内存会被内核回收，但是：因为父进程还可能访问子进程的相关信息，所以内核并不会让子进程彻底消失，而是让子进程变为**僵尸进程**，存储一些有用的信息，等到父进程调用wait()或waitpid()来回收子进程的僵尸状态。

