## 静态库和动态库
| 特性维度       | 静态库                                                       | 动态库                                                           |
| -------------- | ------------------------------------------------------------ | ---------------------------------------------------------------- |
| 文件扩展名     | Windows：.lib<br>Linux：.a                                   | Windows：.dll+.lib<br>Linux：.so                                 |
| 链接时机与方式 | 编译时直接复制库代码到可执行文件内部，运行时不依赖外部库文件 | 编译时只记录引用信息，运行时由系统加载器加载，依赖外部库文件     |
| 内存占用       | 每个程序都包含一份库代码副本，内存占用大                     | 多个程序共享一份库代码，节省内存                                 |
| 更新与部署     | 库更新（无论是接口更新还是实现更新）需重新编译整个程序       | 库文件接口更新需要重新编译程序，实现更新只需要单独重新编译库文件 |
| 加载速度       | 快                                                           | 慢                                                               |

### 动态库链接
1. 编译链接阶段：程序编译时，并不复制动态库的代码，而是需要一个导入库（Windows 下是 .lib文件，它不同于静态库的 .lib，只包含函数符号和重定位信息）或直接读取 .so文件（Linux）来获取库中函数和数据的引用信息
2. 运行加载阶段：当程序启动或运行时，操作系统的加载器会查找并将所需的动态库加载到内存，然后，通过动态链接器完成一个称为“重定位”的过程，将程序中的函数调用地址绑定在内存中动态库的实际地址上。

### 如何取舍
许多大型项目会采用混合策略，将稳定、核心的底层模块编译为静态库，以保证基础部分的独立性和启动性能，将需要频繁更新或可选的扩展性能编译为动态库，以实现灵活性。