## Linux进程间通信方式详解

### 1. 管道（Pipe）
管道是一种最基础的进程通信方式，分为**匿名管道**和**命名管道（FIFO）**。
匿名管道只能用于有亲缘关系的进程（如父子进程），命名管道则可以用于任意进程。

**原理**：管道本质是内核中的一个缓冲区，数据单向流动。写端写入数据，读端读取数据。管道通过文件描述符操作。

**代码示例（匿名管道）**：
```c
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <sys/types.h>

int main() {
	int fd[2]; // fd[0]:读端, fd[1]:写端
	pipe(fd); // 创建管道
	pid_t pid = fork();
	if (pid == 0) { // 子进程
		close(fd[1]); // 关闭写端
		char buf[100];
		int n = read(fd[0], buf, sizeof(buf)); // 从管道读数据
		buf[n] = '\0';
		printf("Child received: %s\n", buf);
		close(fd[0]);
	} else { // 父进程
		close(fd[0]); // 关闭读端
		const char* msg = "Hello from parent!";
		write(fd[1], msg, strlen(msg)); // 写数据到管道
		close(fd[1]);
	}
	return 0;
}
```

---

### 2. 命名管道（FIFO）
命名管道通过文件系统中的**特殊文件**实现，支持无亲缘关系进程通信。

**原理**：使用 `mkfifo` 创建管道文件，进程通过打开该文件进行读写。

**代码示例（FIFO）**：
```c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main() {
	const char* fifo = "/tmp/myfifo"; // 指定命名管道文件的路径，/tmp目录下的myfifo文件将作为管道的标识
	mkfifo(fifo, 0666); // 创建命名管道文件，权限为0666（所有用户可读写）。如果文件已存在则不会重复创建。
	pid_t pid = fork();
	if (pid == 0) { // 子进程
		int fd = open(fifo, O_RDONLY);
		char buf[100];
		int n = read(fd, buf, sizeof(buf));
		buf[n] = '\0';
		printf("Child received: %s\n", buf);
		close(fd);
	} else { // 父进程
		int fd = open(fifo, O_WRONLY);
		const char* msg = "Hello FIFO!";
		write(fd, msg, strlen(msg));
		close(fd);
	}
	return 0;
}
```

---

### 3. 消息队列（Message Queue）
消息队列允许进程**以消息为单位进行通信**，支持**多对多通信**。

**原理**：内核维护一个消息队列，进程通过系统调用向队列发送和接收消息。每条消息有类型和内容。

**代码示例（System V消息队列）**：
```c
#include <sys/ipc.h>   // 提供IPC相关函数和类型
#include <sys/msg.h>   // 提供消息队列相关函数
#include <stdio.h>
#include <string.h>

// 定义消息结构体，必须以long类型的mtype开头
struct msgbuf {
	long mtype;         // 消息类型，必须>0。用于消息过滤和优先级
	char mtext[100];    // 消息正文内容
};

int main() {
	// 1. 生成唯一的key，/tmp是参考文件，66是项目id
	key_t key = ftok("/tmp", 66);
	// 2. 创建或获取一个消息队列，权限为0666（可读写）
	int msgid = msgget(key, IPC_CREAT | 0666);
	// 3. 创建子进程，父子进程通过消息队列通信
	pid_t pid = fork();
	if (pid == 0) { // 子进程：负责接收消息
		struct msgbuf msg;
		// 4. 从消息队列接收类型为1的消息，阻塞直到收到
		//    msgid: 队列id，msg: 接收缓冲区，sizeof(msg.mtext):接收正文长度，1:消息类型，0:阻塞
		msgrcv(msgid, &msg, sizeof(msg.mtext), 1, 0);
		printf("Child received: %s\n", msg.mtext); // 打印收到的消息
	} else { // 父进程：负责发送消息
		struct msgbuf msg;
		msg.mtype = 1; // 设置消息类型为1
		strcpy(msg.mtext, "Hello Message Queue!"); // 填充消息内容
		// 5. 发送消息到队列
		//    msgid: 队列id，msg: 发送缓冲区，strlen+1:包含\0，0:默认阻塞
		msgsnd(msgid, &msg, strlen(msg.mtext)+1, 0);
	}
	// 6. 程序结束，消息队列未删除（可用ipcrm命令手动删除）
	return 0;
}
```

---

### 4. 共享内存（Shared Memory）
共享内存是**最快**的进程通信方式，允许多个进程直接访问同一块内存。

**原理**：通过 `shmget`/`shmat` 或 `mmap` 映射一块内存区域，所有进程都能读写。通常需配合信号量或互斥锁实现同步。

**代码示例（System V共享内存）**：
```c
#include <sys/ipc.h>
#include <sys/shm.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

int main() {
	key_t key = ftok("/tmp", 67);
	int shmid = shmget(key, 1024, IPC_CREAT | 0666); // 创建共享内存
	char* shmaddr = (char*)shmat(shmid, NULL, 0); // 映射到进程地址空间
	pid_t pid = fork();
	if (pid == 0) { // 子进程
		sleep(1); // 等待父进程写入
		printf("Child read: %s\n", shmaddr);
	} else { // 父进程
		strcpy(shmaddr, "Hello Shared Memory!"); // 写入共享内存
	}
	shmdt(shmaddr); // 解除映射
	return 0;
}
```

---

### 5. 信号（Signal）
信号是一种异步通知机制，常用于进程间事件通知或异常处理。

**原理**：内核向进程发送信号，进程可以捕获信号并执行相应处理。常用于通知、终止、暂停等。

**代码示例**：
```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

void handler(int sig) {
	printf("Received signal %d\n", sig);
}

int main() {
	signal(SIGUSR1, handler); // 注册信号处理函数
	pid_t pid = fork();
	if (pid == 0) {
		sleep(1);
		kill(getppid(), SIGUSR1); // 子进程向父进程发送信号
	} else {
		pause(); // 等待信号
	}
	return 0;
}
```

---

### 6. 套接字（Socket）
套接字是最灵活的进程通信方式，支持本地和网络通信。

**原理**：通过 socket 接口，进程可以在同一台机器或不同机器间进行数据交换。支持流式（TCP）和数据报（UDP）通信。

**代码示例（本地UNIX域套接字）**：
```c
#include <sys/socket.h>   // 套接字相关API
#include <sys/un.h>       // UNIX域套接字地址结构
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main() {
	const char* path = "/tmp/unix.sock"; // 指定UNIX域套接字文件路径
	int listen_fd = socket(AF_UNIX, SOCK_STREAM, 0); // 创建监听套接字，AF_UNIX表示本地通信，SOCK_STREAM为字节流

	struct sockaddr_un addr; // 地址结构体
	addr.sun_family = AF_UNIX; // 设置地址族为UNIX域
	strcpy(addr.sun_path, path); // 设置套接字文件路径

	bind(listen_fd, (struct sockaddr*)&addr, sizeof(addr)); // 绑定监听套接字到指定路径
	listen(listen_fd, 1); // 开始监听，允许1个连接排队

	pid_t pid = fork(); // 创建子进程
	if (pid == 0) { // 子进程：作为客户端
		int client_fd = socket(AF_UNIX, SOCK_STREAM, 0); // 创建客户端套接字
		// connect用于将客户端套接字client_fd连接到服务器端指定的UNIX域套接字地址：
		// 参数1：client_fd，客户端套接字描述符
		// 参数2：(struct sockaddr*)&addr，指向服务器端地址结构体的指针（需强转为sockaddr*类型）
		// 参数3：sizeof(addr)，地址结构体的字节大小
		// 调用后，client_fd与服务器端listen_fd建立连接，可以进行数据收发
		connect(client_fd, (struct sockaddr*)&addr, sizeof(addr)); // 连接到服务器端
		const char* msg = "Hello Socket!"; // 要发送的消息
		write(client_fd, msg, strlen(msg)); // 发送消息到服务器
		close(client_fd); // 关闭客户端套接字
	} else { // 父进程：作为服务器
		int conn_fd = accept(listen_fd, NULL, NULL); // 接受客户端连接，返回新的连接套接字
		char buf[100];
		int n = read(conn_fd, buf, sizeof(buf)); // 读取客户端发送的数据
		buf[n] = '\0'; // 添加字符串结束符
		printf("Parent received: %s\n", buf); // 打印收到的消息
		close(conn_fd); // 关闭连接套接字
		close(listen_fd); // 关闭监听套接字
	}
	return 0;
}
```

---

### 7. 其他：内存映射文件（mmap）、信号量（semaphore）、事件通知等
这些方式常用于特殊场景或与上述方式结合使用。

**原理**：
- mmap：通过文件映射实现共享内存。
- 信号量：用于进程间同步，常与共享内存结合。
- 事件通知：如 inotify、epoll 等。

**代码示例（mmap共享内存）**：
```c
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

int main() {
	int fd = open("/tmp/mmapfile", O_CREAT | O_RDWR, 0666);
	ftruncate(fd, 1024); // 设置文件大小
	char* addr = (char*)mmap(NULL, 1024, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
	pid_t pid = fork();
	if (pid == 0) {
		sleep(1);
		printf("Child read: %s\n", addr);
	} else {
		strcpy(addr, "Hello mmap!");
	}
	munmap(addr, 1024);
	close(fd);
	return 0;
}
```

---

> 以上每种通信方式都适用于不同场景，选择时需考虑效率、同步需求、进程关系、数据量等因素。
