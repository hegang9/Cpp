### 对比
| 特性维度  | 用户进程                             | 用户线程                             | 内核线程                             | 内核进程                                                      |
| --------- | ------------------------------------ | ------------------------------------ | ------------------------------------ | ------------------------------------------------------------- |
| 本质      | 资源拥有的基本单位                   | CPU调度的基本单位                    | 内核的“仆人”，执行系统后台任务       | 在Linux中，内核并不严格区分进程和线程，内核线程就是它的“进程” |
| 创建方式  | fork()                               | pthread_create()                     | kthread_create()                     | 内核初始化时创建（如kthreadd）                                |
| 运行空间  | 主要在用户态，通过系统调用陷入内核态 | 主要在用户态                         | 始终在内核态                         | 始终在内核态                                                  |
| 资源隔离​ | 拥有独立的地址空间、文件描述符表等   | 共享其所属进程的地址空间、文件等资源 | 通常共享内核数据，但可能有独立上下文 | 共享内核地址空间，但可能有独立的内核栈                        |
| 调度单位  | 其内部的主线程是调度单位             | 直接作为调度单位                     | 直接作为调度单位                     | 直接作为调度单位                                              |

### 用户态和内核态：
- 用户态：位于操作系统上层（不包括操作系统本身），都运行在用户态中，用户态智能执行一部分机器指令，不可以运行I/O命令或者影响机器控制的命令；
- 内核态：操作系统层，可以访问所有硬件设备，也可以执行硬件上能够运行的各种指令。

### 用户级线程和内核级线程
- 用户级线程：线程间的切换在用户态完成，用户级线程可以看作是由编程语言的运行时库或线程库在用户空间模拟出来的。内核对此一无所知，它的视野里只有一个普通的“进程”。一个线程阻塞导致整个进程阻塞，**CPU还是根据进程分配时间片**，无法利用多核。相当于只是**模拟**。
- 内核级线程：现代操作系统的主流模型。在这种模型下，线程是内核直接支持的调度单位。每个线程在内核中都有对应的线程控制块（TCB）。当需要切换线程时（例如时间片用完、线程主动阻塞），必须通过系统调用陷入内核，由内核调度器来执行切换操作。是真正的并发，**CPU根据线程分配时间片**，可以利用多核CPU。但是切换代价较用户级线程大。
- 当前的Windows和Linux系统的线程实现都属于一对一（即一个用户线程对应一个内核线程），这意味着线程的创建、切换、调度等操作都需要内核参与，也就都需要在内核态中进行。然而，现代线程库为了追求极致性能，会进行大量优化，例如线程库可能会尝试在用户态通过自旋或无锁编程先解决问题，只有在确实需要阻塞时，才会陷入内核将线程挂起。

### 切换时需要保存的资源
前导知识：每个进程拥有独立的虚拟地址空间，拥有独立的内核栈和用户栈；
- 用户栈：处于用户空间，支持用户态函数调用，每个用户线程都有自己独立的用户栈。
- 内核栈：处于内核空间，支持内核态代码运行，每个线程有自己独立的内核栈。

| 资源类别                    | 用户线程->用户线程<br>（同一进程内） | 用户进程->用户进程        | 内核线程->内核线程             | 用户线程->内核线程/内核线程->用户线程<br>（涉及用户态和内核态的转换） |
| --------------------------- | ------------------------------------ | ------------------------- | ------------------------------ | --------------------------------------------------------------------- |
| CPU寄存器上下文             | 必须保存                             | 必须保存                  | 必须保存                       | 必须保存                                                              |
| 内存资源（页表/地址空间等） | 不切换                               | 必须切换                  | 通常不切换（共享内核地址空间） | 可能切换                                                              |
| 栈资源                      | 仅切换用户栈指针                     | 切换用户栈和内核栈        | 切换内核栈指针                 | 切换栈指针，从用户栈切换到内核栈或反向恢复                            |
| 其他需要保存的状态信息      | 线程局部存储                         | 文件描述符表/信号处理表等 | 内核锁状态/调度优先级等        | 硬件浮点单元状态/系统调用上下文等                                     |

### 在Linux中创建进程和线程
在Linux中，进程和线程都是task_struct，通过clone_flags控制资源共享程度间接区分线程和线程。 
- Linux进程管理：
Linux内核启动开始，会创建0号进程，是所有进程的祖先，接下来紧接着创建1号和2号进程，1号进程是第一个用户进程，是所有用户线程的父线程；2号进程是内核线程的管理者，负责创建和管理内核线程。
- Linux线程管理：
在linux中使用pthread_create创建线程，底层使用clone系统调用（clone和fork实际上调用的是同一个接口kernel_clone，区别在于clone_falgs）。线程会设置共享标志位，通过增加引用计数而非复制的方式来共享进程资源。