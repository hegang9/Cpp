### 进程创建方法
使用fork()系统调用创建进程，遵循“写时复制”机制

### 写时复制机制
fork()后，父子进程的代码段、全局变量、堆内存、栈内存等初始共享同一物理内存页，但被内核标记为只读。当任一进程尝试写入时，会触发缺页异常，内核此时才会为该进程复制一份新的物理页供其修改，从而保持隔离

### 父子进程共享的资源
| 资源类别                 | 是否共享 | 描述                                                                                                                                                                       |
| ------------------------ | -------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 内存空间（数据段和堆栈） | 写时复制 | 见上文                                                                                                                                                                     |
| 打开的文件描述符         | 是       | 子进程会获得父进程文件描述符表的副本，这意味着它们指向相同的打开文件描述。因此，父子进程共享文件偏移量。<br>对同一个文件进行读写操作时，如果不进行同步，输出可能会相互混合 |
| 信号处理方式             | 是       | 子进程会继承父进程为各信号设置的处置方式                                                                                                                                   |
| 进程凭证                 | 是       | 实际/有效用户ID、实际/有效组ID、附加组ID、进程组ID、会话ID等都会被继承                                                                                                     |
| 文件系统相关属性         | 是       | 当前工作目录、根目录、文件模式创建屏蔽字会被子进程继承                                                                                                                     |
| 信号量调整值             | 是       | 对某个信号设定的信号量调整值会被继承                                                                                                                                       |
| 进程ID                   | 否       | 子进程拥有全新且唯一的ID                                                                                                                                                   |
| 文件锁                   | 否       | 父进程设置的锁不会被继承                                                                                                                                                   |
| 待处理信号               | 否       | 子进程会清空待处理的信号集                                                                                                                                                 |

由于父子进程的文件描述符表是相同的，所以在对共享的文件进行读写时，一定要使用同步机制（锁、信号量）来避免竞态条件

### 进程资源清理
子进程退出后，其占用的内存会被内核回收，但是：因为父进程还可能访问子进程的相关信息，所以内核并不会让子进程彻底消失，而是让子进程变为**僵尸进程**，存储一些有用的信息，等到父进程调用wait()或waitpid()来回收子进程的僵尸状态。