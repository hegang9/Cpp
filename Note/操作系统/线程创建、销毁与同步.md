### 线程创建方法
两种主流方案：POSIX线程库和C++11标准线程库，后面以C++11标准库为例。
- POSIX线程库：POSIX线程库使用POSIX标准，跨平台性较差，需显式链接，且严格要求线程函数的原型为void* func(void*)，需手动管理资源，不支持RAII，使用C代码风格，兼容老式Unix系统或与C代码交互。


### 线程资源共享
| 资源类别       | 是否共享 | 关键点说明                                                                            |
| -------------- | -------- | ------------------------------------------------------------------------------------- |
| 内存地址空间   | 共享     | 包括代码段、数据段和堆空间。意味着全局变量、静态变量、动态分配的内存对所有内存均可见  |
| 文件描述符     | 共享     | 进程打开的文件、套接字等，其描述符对所有线程开放，多个线程可操作同一文件              |
| 工作目录与身份 | 共享     | 当前工作目录、用户ID、组ID等进程级环境信息是共享的                                    |
| 信号处理方式   | 共享     | 为信号设置的处理函数（如SIGINT的处理句柄）是进程范围内共享的                          |
| 栈空间         | 独享     | 每个线程拥有自己独立的调用栈，用于保存局部变量、函数调用地址等                        |
| 寄存器状态     | 独享     | 线程是调度的基本单位，切换时需要保存/恢复的寄存器状态（如程序计数器、栈指针）是独立的 |
| 线程特定数据   | 独享     | 如线程ID、错误码errno、信号屏蔽字等，是每个线程私有的                                 |

### 线程销毁
已join或detach的thread对象中的函数运行结束后自动析构

### 线程同步方法
| 同步机制 | 核心原理                                                     | 主要特点                                                        | 适用场景                                       |
| -------- | ------------------------------------------------------------ | --------------------------------------------------------------- | ---------------------------------------------- |
| 互斥锁   | 保护一个临界区，一次只允许一个线程进入                       | 涉及内核态切换，可跨进程同步                                    | 需要跨进程进行线程同步的场景                   |
| 信号量   | 维护一个许可证计数器，控制同时访问资源的线程数               | 可跨进程，可控制并发线程数量                                    | 线程池、连接池等需要限制资源访问数量的场景     |
| 条件变量 | 允许线程在某个条件不满足时主动等待，并在条件可能满足时被唤醒 | 不单独使用，需与互斥锁配合，用于复杂的线程协作                  | 生产者-消费者等需要等待特定条件的场景          |
| 读写锁   | 区分读写操作，允许多个读线程并发，但写线程独占               | 提高读多写少场景下的并发性能                                    | 缓存、配置信息等读多写少的共享数据             |
| 自旋锁   | 线程通过循环检查（忙等待）​ 来获取锁，而非阻塞               | 避免线程上下文切换开销（也就是占着茅坑不拉屎），但空转会消耗CPU | 临界区执行时间极短，且不希望发生线程切换的场景 |
| 原子操作 | 利用CPU硬件指令保证单个操作（如递增）的不可分割性            | 无锁编程，性能最高                                              | 简单的计数器、状态标志等单一变量的线程安全操作 |

### 僵尸线程
已经执行完毕但是线程控制块等资源未注销的线程称为僵尸线程，产生僵尸线程的原因为没有使用join或detach或者主线程先于子线程退出（通常情况下这会导致所有子线程被强制终止并释放资源，但是若主线程在join或detach前退出，可能会导致僵尸线程）