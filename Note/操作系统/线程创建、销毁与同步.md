### 线程创建方法
两种主流方案：POSIX线程库和C++11标准线程库，后面以C++11标准库为例。
- POSIX线程库：POSIX线程库使用POSIX标准，跨平台性较差，需显式链接，且严格要求线程函数的原型为void* func(void*)，需手动管理资源，不支持RAII，使用C代码风格，兼容老式Unix系统或与C代码交互。


### 线程资源共享
| 资源类别       | 是否共享 | 关键点说明                                                                            |
| -------------- | -------- | ------------------------------------------------------------------------------------- |
| 内存地址空间   | 共享     | 包括代码段、数据段和堆空间。意味着全局变量、静态变量、动态分配的内存对所有内存均可见  |
| 文件描述符     | 共享     | 进程打开的文件、套接字等，其描述符对所有线程开放，多个线程可操作同一文件              |
| 工作目录与身份 | 共享     | 当前工作目录、用户ID、组ID等进程级环境信息是共享的                                    |
| 信号处理方式   | 共享     | 为信号设置的处理函数（如SIGINT的处理句柄）是进程范围内共享的                          |
| 栈空间         | 独享     | 每个线程拥有自己独立的调用栈，用于保存局部变量、函数调用地址等                        |
| 寄存器状态     | 独享     | 线程是调度的基本单位，切换时需要保存/恢复的寄存器状态（如程序计数器、栈指针）是独立的 |
| 线程特定数据   | 独享     | 如线程ID、错误码errno、信号屏蔽字等，是每个线程私有的                                 |

### 线程销毁
已join或detach的thread对象中的函数运行结束后自动析构

### 线程同步方法
| 同步机制 | 核心原理                                                     | 主要特点                                                        | 适用场景                                       |
| -------- | ------------------------------------------------------------ | --------------------------------------------------------------- | ---------------------------------------------- |
| 互斥锁   | 保护一个临界区，一次只允许一个线程进入                       | 涉及内核态切换，可跨进程同步                                    | 需要跨进程进行线程同步的场景                   |
| 信号量   | 维护一个许可证计数器，控制同时访问资源的线程数               | 可跨进程，可控制并发线程数量                                    | 线程池、连接池等需要限制资源访问数量的场景     |
| 条件变量 | 允许线程在某个条件不满足时主动等待，并在条件可能满足时被唤醒 | 不单独使用，需与互斥锁配合，用于复杂的线程协作                  | 生产者-消费者等需要等待特定条件的场景          |
| 读写锁   | 区分读写操作，允许多个读线程并发，但写线程独占               | 提高读多写少场景下的并发性能                                    | 缓存、配置信息等读多写少的共享数据             |
| 自旋锁   | 线程通过循环检查（忙等待）​ 来获取锁，而非阻塞               | 避免线程上下文切换开销（也就是占着茅坑不拉屎），但空转会消耗CPU | 临界区执行时间极短，且不希望发生线程切换的场景 |
| 原子操作 | 利用CPU硬件指令保证单个操作（如递增）的不可分割性            | 无锁编程，性能最高                                              | 简单的计数器、状态标志等单一变量的线程安全操作 |

### 僵尸线程
已经执行完毕但是线程控制块等资源未注销的线程称为僵尸线程，产生僵尸线程的原因为没有使用join或detach或者主线程先于子线程退出（通常情况下这会导致所有子线程被强制终止并释放资源，但是若主线程在join或detach前退出，可能会导致僵尸线程）

---

## 线程同步方法详解与示例（C++11）

### 互斥锁（mutex）
**核心点**：保护临界区，同一时刻只允许一个线程进入。

```cpp
#include <mutex>
#include <thread>
#include <vector>

std::vector<int> data;
std::mutex mtx;

void push_value(int v) {
	std::lock_guard<std::mutex> lk(mtx); // 自动加锁，作用域结束自动解锁
	data.push_back(v);                  // 临界区：写共享容器
}
```

### 条件变量（condition_variable）
**核心点**：用于线程间等待/通知，必须与互斥锁配合。

```cpp
#include <condition_variable>
#include <mutex>
#include <queue>

std::queue<int> q;
std::mutex mtx;
std::condition_variable cv;

void producer(int v) {
	{
		std::lock_guard<std::mutex> lk(mtx); // 保护队列
		q.push(v);                           // 修改共享数据
	}
	cv.notify_one();                       // 通知一个等待线程
}

int consumer() {
	std::unique_lock<std::mutex> lk(mtx);  // 可用于条件变量等待的锁
	cv.wait(lk, [] { return !q.empty(); }); // 条件满足前阻塞等待
	int v = q.front();                     // 读取共享数据
	q.pop();                               // 修改共享数据
	return v;                              // 返回消费结果
}
```

#### 补充：伪唤醒
**条件变量只保证被唤醒之后可以重新竞争锁，不保证条件仍然成立**。当多个线程被唤醒，发生其中一个线程先获取锁，并将条件改回不满足，接着下一个线程获取锁，此时条件不满足但还是被唤醒了，这就发生了伪唤醒。

发生伪唤醒的原因有三个：
1. 实现层面允许：标准明确允许条件变量出现伪唤醒，以换取实现上的简化与性能优化。
2. 竞争与调度：多个线程同时被唤醒或竞争锁时，只有一个线程真正满足条件，其他线程就“空醒”。
3. 广播唤醒：notify_all 会唤醒所有等待者，绝大部分线程的条件仍不满足。

解决办法：
- 等待＋条件检查：用循环或谓词反复检查条件
```c++
cv.wait(lk, [] { return !q.empty(); }); // 谓词

// 循环，与上面的谓词方法等价
while (!q.empty() == false) {
    cv.wait(lk);
}
```

### 读写锁（shared_mutex）
**核心点**：读共享、写独占，适合读多写少。

```cpp
#include <shared_mutex>
#include <unordered_map>

std::unordered_map<int, int> mp;
std::shared_mutex rw_mtx;

int read_value(int k) {
	std::shared_lock<std::shared_mutex> lk(rw_mtx); // 读锁：允许并发读
	auto it = mp.find(k);                           // 只读访问
	return it == mp.end() ? -1 : it->second;        // 返回查找结果
}

void write_value(int k, int v) {
	std::unique_lock<std::shared_mutex> lk(rw_mtx); // 写锁：独占
	mp[k] = v;                                      // 修改共享数据
}
```

### 自旋锁（spinlock，基于原子）
**核心点**：忙等待，适合临界区极短的场景。

```cpp
#include <atomic> 

class SpinLock {
public:
    void lock() {
        // 尝试将 flag 从 false 置为 true，如果已经为 true（被其他线程持有），则不断循环尝试
        while (flag.test_and_set(std::memory_order_acquire)) {}
    }
    void unlock() {
        // 释放锁，将 flag 重新置为 false
        flag.clear(std::memory_order_release);
    }
private:
    std::atomic_flag flag = ATOMIC_FLAG_INIT; // 原子布尔标志，初始为 false（未加锁）
};

SpinLock sp;
int counter = 0;

void add_one() {
    sp.lock();   // 进入临界区，只有获得锁的线程能执行下面的代码
    ++counter;   // 修改共享变量
    sp.unlock(); // 离开临界区，释放锁
}
```

适用场景：临界区代码极短，线程数不多，且锁竞争不激烈时，自旋锁比互斥锁更高效，因为避免了线程挂起/唤醒的系统调用开销。

### 原子操作（atomic）
**核心点**：无锁保证单变量操作原子性，开销低。

```cpp
#include <atomic>

std::atomic<int> cnt{0};

void inc() {
	cnt.fetch_add(1, std::memory_order_relaxed); // 原子递增，无需加锁
}
```

### 信号量（semaphore，C++20）
**核心点**：控制并发访问数量，适合资源池。

信号量原理：

- 信号量是一种计数同步原语，本质上维护一个“许可计数器”
- 初值：表示可用资源的数量（如最大并发数、池中剩余对象数）
- acquire()：尝试获取一个许可。如果计数器大于0，则减1并立即返回；如果为0，则阻塞等待直到有许可可用。
- release()：释放一个许可，计数器加1。如果有线程在等待，则唤醒其中一个。

```cpp
#include <semaphore>

std::counting_semaphore<3> sem(3); // 最多 3 个并发许可

void use_resource() {
	sem.acquire(); // 申请许可，不足则阻塞
	// 使用资源
	sem.release(); // 释放许可
}
```

### 屏障（barrier，C++20）
**核心点**：让一组线程在同一点等待，直到全部到达再同时继续。

```cpp
#include <barrier>
#include <thread>
#include <vector>

constexpr int N = 3;
std::barrier sync_point(N);

void work(int id) {
	// 第一阶段
	// ... 执行阶段任务
	sync_point.arrive_and_wait(); // 等待所有线程到达

	// 第二阶段
	// ... 执行阶段任务
	sync_point.arrive_and_wait(); // 再次同步
}

int main() {
	std::vector<std::thread> ts;
	for (int i = 0; i < N; ++i) {
		ts.emplace_back(work, i);
	}
	for (auto &t : ts) t.join();
}
```

### 闭锁（latch，C++20）
**核心点**：一次性计数同步，计数归零后所有等待线程继续。

```cpp
#include <latch>
#include <thread>
#include <vector>

constexpr int N = 3;
std::latch done(N);

void worker() {
	// 执行任务
	done.count_down(); // 计数减一
}

int main() {
	std::vector<std::thread> ts;
	for (int i = 0; i < N; ++i) {
		ts.emplace_back(worker);
	}
	done.wait(); // 阻塞直到计数归零
	for (auto &t : ts) t.join();
}
```

### 期望值与承诺（future/promise）
**核心点**：线程间结果传递与同步等待。

```cpp
#include <future>
#include <thread>

std::promise<int> prom;
std::future<int> fut = prom.get_future();

void worker() {
	prom.set_value(42); // 设置结果并唤醒等待者
}

int main() {
	std::thread t(worker);
	int v = fut.get(); // 阻塞等待结果
	t.join();
}
```

### 打包任务（packaged_task）
**核心点**：将可调用对象打包成异步任务，获取 future 同步结果。

```cpp
#include <future>
#include <thread>

int calc(int x) { return x * x; }

int main() {
	std::packaged_task<int(int)> task(calc); // 打包可调用对象
	std::future<int> fut = task.get_future(); // 绑定 future
	std::thread t(std::move(task), 6);       // 在线程中执行任务
	int v = fut.get();                       // 等待结果
	t.join();
}
```

### 异步任务（async）
**核心点**：由运行时决定线程/延迟执行，future 用于同步。

```cpp
#include <future>

int calc(int x) { return x + 1; }

int main() {
	auto fut = std::async(std::launch::async, calc, 10); // 异步执行
	int v = fut.get();                                  // 等待结果
}
```

### 条件变量变体（condition_variable_any）
**核心点**：支持任意可锁类型（如 shared_mutex 的 unique_lock）。

```cpp
#include <condition_variable>
#include <mutex>

std::mutex mtx;
std::condition_variable_any cv_any;
bool ready = false;

void wait_ready() {
	std::unique_lock<std::mutex> lk(mtx);         // 保护共享状态
	cv_any.wait(lk, [] { return ready; });        // 等待条件满足
}

void set_ready() {
	{
		std::lock_guard<std::mutex> lk(mtx);        // 修改共享状态
		ready = true;
	}
	cv_any.notify_all();                          // 唤醒所有等待者
}
```