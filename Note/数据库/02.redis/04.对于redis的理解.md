# 04.对于redis的理解

redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。和Memcached类似。redis支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)和zset(有序集合)。

### 一、 基本介绍

redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)和zset(有序集合)。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。

Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类keyvalue存储的不足，在部 分场合可以对关系数据库起到很好的补充作用。它提供了Python，Ruby，Erlang，PHP客户端，使用很方便。

### 二、 常用命令

就DB来说，Redis成绩已经很惊人了，且不说memcachedb和tokyocabinet之流，就说原版的memcached，速度似乎也只能达到这个级别。Redis根本是使用内存存储，持久化的关键是这三条指令：SAVE BGSAVE LASTSAVE …

当接收到SAVE指令的时候，Redis就会dump数据到一个文件里面。

值得一说的是它的独家功能：存储列表和集合，这是它与mc之流相比更有竞争力的地方。

不介绍mc里面已经有的东东，只列出特殊的：

TYPE key — 用来获取某key的类型

KEYS pattern — 匹配所有符合模式的key，比如KEYS * 就列出所有的key了，当然，复杂度O(n)

RANDOMKEY – 返回随机的一个key

RENAME oldkey newkey — key也可以改名

列表操作，精华

RPUSH key string — 将某个值加入到一个key列表头部

LPUSH key string — 将某个值加入到一个key列表末尾

LLEN key — 列表长度

LRANGE key start end — 返回列表中某个范围的值，相当于mysql里面的分页查询那样

LTRIM key start end — 只保留列表中某个范围的值

LINDEX key index — 获取列表中特定索引号的值，要注意是O(n)复杂度

LSET key index value — 设置列表中某个位置的值

### 三、 redis存储

redis使用了两种文件格式：全量数据和增量请求。全量数据格式是把内存中的数据写入磁盘，

便于下次读取文件进行加载；增量请求文件则是把内存中的数据序列化为操作请求，用于读取文件进行replay得到数据，序列化的操作包括SET、RPUSH、SADD、ZADD。

redis的存储分为内存存储、磁盘存储和log文件三部分，配置文件中有三个参数对其进行配置。

save seconds updates，save配置，指出在多长时间内，有多少次更新操作，就将数据同步到数据文件。这个可以多个条件配合，比如默认配置文件中的设置，就设置了三个条件。

appendonly yes/no ，appendonly配置，指出是否在每次更新操作后进行日志记录，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为redis本身同步数据文件是按上面的save条件来同步的，所以有的数据会在一段时间内只存在于内存中。

appendfsync no/always/everysec ，appendfsync配置，no表示等操作系统进行数据缓存同步到磁盘，always表示每次更新操作后手动调用fsync()将数据写到磁盘，everysec表示每秒同步一次。